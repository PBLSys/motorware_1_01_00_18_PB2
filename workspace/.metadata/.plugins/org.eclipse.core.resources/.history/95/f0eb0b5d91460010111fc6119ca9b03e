//! \defgroup PROJ_LAB05a PROJ_LAB05a    PB2 // wheel side motor ie non-wheel side of device
//@{
//! \defgroup PROJ_LAB05a_OVERVIEW Project Overview
//! Adjusting the supplied current controllers
// **************************************************************************
// system includes
#include <math.h>
#include "main.h"

#ifdef FLASH
#pragma CODE_SECTION(mainISR,"ramfuncs");
#endif

// Include header files used in the main function

// **************************************************************************
// the defines
#define LED_BLINK_FREQ_Hz                   (5)

#define FakePodium
//#define FakePodium_Rivu
//#define Rev6
//#define Rev9

#ifdef FakePodium
#define Undervoltage_bus_centiV                 (1000)
#define CIRCUMFERENCE_1TURN_decimm              (2500.0)
#endif

#ifdef FakePodium_Rivu
#define Undervoltage_bus_centiV                 (1000)
#define CIRCUMFERENCE_1TURN_decimm              (2500.0)
#endif

#ifdef Rev6
#define Undervoltage_bus_centiV                 (4200)
#define CIRCUMFERENCE_1TURN_decimm              (755.9)
#endif

#ifdef Rev9
#define Undervoltage_bus_centiV                 (4000) // chris's device has LFP cells 12v pack x 4 in series.
#define CIRCUMFERENCE_1TURN_decimm              (755.9)
#endif

#define roller_to_handle_decimm                 (3110.0)
#define roller_to_bar_decimm                    (1082.0)
#define platform_to_roller_decimm               (950.0)
#define ticks_to_decimm_conversion              (CIRCUMFERENCE_1TURN_decimm * USER_1_BY_1TURN)
#define ticks_to_decimm_conversion_by10          (ticks_to_decimm_conversion / 10.0)
#define decimm_to_ticks_conversion              (1/ticks_to_decimm_conversion)
#define start_force_position_ramp_decimm        (250.0) // 1 inch
#define start_force_position_ramp               (start_force_position_ramp_decimm * decimm_to_ticks_conversion)
#define reciprocal_start_force_position_ramp    (1.0/start_force_position_ramp)
#define start_force_position_mm_max             (2438.0) // 7.9986 feet
#define start_force_position_decimm_max         (start_force_position_mm_max * 10.0)
#define start_force_position_mm_used_max        (start_force_position_mm_max - platform_to_roller_mm)
#define start_force_position_max                (((USER_MOTOR_START_TURN + ((float)start_force_position_mm_used_max * reciprocal_CIRCUMFERENCE_1TURN_mm)) * USER_COUNT_1TURN) - 1)
#define range_of_motion_commitment_constant_decimm (125.0) // 1/2 inch
#define range_of_motion_commitment_constant     ((uint16_t)(range_of_motion_commitment_constant_decimm * decimm_to_ticks_conversion))
#define range_of_motion_commitment_constantx2   ((uint16_t)(2.0 * range_of_motion_commitment_constant))
#define rep_forgiveness_percent_at_top          (20/100) // 20% forgiveness at top
#define rep_forgiveness_percent_at_bottom       (20/100) // 20% forgiveness at bottom
#define rep_forgiveness_band_decimm_at_top       (250.0)
#define rep_forgiveness_band_decimm_at_bottom    (250.0)
#define rep_forgiveness_band_ticks_at_top       ((uint16_t)(rep_forgiveness_band_decimm_at_top * decimm_to_ticks_conversion))
#define rep_forgiveness_band_ticks_at_bottom    ((uint16_t)(rep_forgiveness_band_decimm_at_bottom * decimm_to_ticks_conversion))
#define ball_position_decimm_reset              (platform_to_roller_decimm + 500.0)

/* Packet Headers */
#define Position_Packet_Header                  0x00A0
#define Status_Packet_Header                    0x00B1
#define MotorForce_Measured_Header              0x00E4
#define MotorForce_Setting_Header               0x00F5
#define start_force_position_Setting_Header     0x00A6
#define MotorAdvancedForce_Setting_Header       0x00B7
#define Accel_Header                            0x00C8
#define Velocity_Header                         0x00D9
#define ROM_min_Header                          0x00E1
#define ROM_max_Header                          0x00F2
#define Tballs_Bballs_Header                    0x00A3
#define Loadcell_packet_header                  0x00B4
#define send_packet_over_serial_counter_header  0x00C5

#define Send_Position_Packet_1                  0x00A0
#define Send_MotorForce_Measured                0x00A1
#define Send_MotorForce_Setting                 0x00A2
#define Send_start_force_position_Setting       0x00A3
#define Send_MotorAdvancedForce_Setting         0x00A4
#define Send_Position_Packet_2                  0x00A5
#define Send_Accel                              0x00A6
#define Send_Velocity                           0x00A7
#define Send_ROM_min                            0x00A8
#define Send_ROM_max                            0x00A9
#define Send_Position_Packet_3                  0x00AA
#define Send_Tballs_Bballs                      0x00AB
#define Send_Status_Packet                      0x00AC
#define Send_Loadcell_packet                    0x00AD
#define Send_send_packet_over_serial_counter    0x00AE

#define ROM_Bottom_1                            (213)
#define ROM_Concentric_1A                       (214)
#define ROM_Concentric_1B                       (215)
#define ROM_Eccentric_1A                        (216)
#define ROM_Eccentric_1B                        (217)
#define ROM_Concentric_2A                       (218)
#define ROM_Concentric                          (219)
#define ROM_Top                                 (220)
#define ROM_Eccentric                           (221)
#define ROM_Bottom                              (222)

#define BLE_set_all_variables_in_one_packet_header        		0x5152
#define send_packet_over_ble_header                             0x4142
#define send_packet_over_ble_gather_data_step0                  0x00BF
#define send_packet_over_ble_gather_data_step1                  0x00C0
#define send_packet_over_ble_gather_data_step2                  0x00C1
#define send_packet_over_ble_gather_data_step3                  0x00C2
#define send_packet_over_ble_gather_data_step4                  0x00C3
#define send_packet_over_ble_gather_crc16_step                  0x00D8
#define send_packet_over_ble_point_to_1st_central_step          0x00C4
#define send_packet_over_ble_send_4bytes_step1                  0x00C5
#define send_packet_over_ble_send_4bytes_step2                  0x00C6
#define send_packet_over_ble_send_4bytes_step3                  0x00C7
#define send_packet_over_ble_send_4bytes_step4                  0x00C8
#define send_packet_over_ble_send_4bytes_step5                  0x00C9
#define send_packet_over_ble_send_4bytes_step6                  0x00CA
#define send_packet_over_ble_send_4bytes_step7                  0x00CB
#define send_packet_over_ble_send_4bytes_step8                  0x00CC
#define send_packet_over_ble_send_4bytes_step9                  0x00CD
#define send_packet_over_ble_send_4bytes_step10                 0x00CE
#define send_packet_over_ble_send_4bytes_step11                 0x00CF
#define send_packet_over_ble_send_4bytes_step12                 0x00D1
#define send_packet_over_ble_send_4bytes_step13                 0x00D2
#define send_packet_over_ble_send_4bytes_step14                 0x00D3
#define send_packet_over_ble_send_4bytes_step15                 0x00D4
#define send_packet_over_ble_send_4bytes_step16                 0x00D5
#define send_packet_over_ble_bypass_step1                       0x00D7
#define send_packet_over_ble_bypass_step2                       0x00D9
#define read_packet_over_ble_step0                              0x0090
#define read_packet_over_ble_step1                              0x0091
#define read_packet_over_ble_step2                              0x0092
#define ble_response_array_size           						(62)

#define roller_to_handle_mm               (311.0)
#define roller_to_bar_mm                  (108.0)
#define platform_to_roller_mm             (95.0)
#define wt_centilb_default               (500)
#define wt_lb_default                     (wt_centilb_default/100.0)
#define wt_centilb_max_limit             (11000)
#define IqRef_pu_pos_max_init              (USER_MOTOR_MAX_CURRENT/USER_IQ_FULL_SCALE_CURRENT_A)
#define IqRef_pu_neg_max_init              (-IqRef_pu_pos_max_init)
#define IqRef_A_min_limit                 (-1.0) //(-wt_centilb_default/200.0)
#define IqRef_A_max_limit                 (-wt_centilb_max_limit/200.0)

#define LOG_ARRAY_SIZE                                          (9000)//(4500)
#define ball_position_circular_buffer_size                      (10)
#define ball_position_circular_buffer_size_minus_1              (ball_position_circular_buffer_size-1)
#define ball_velocityx10_circular_buffer_size                   (20)
#define ball_velocityx10_circular_buffer_size_minus_1           (ball_velocityx10_circular_buffer_size-1)
#define ball_accelx200_circular_buffer_size                     (200)
#define ball_accelx200_circular_buffer_size_minus_1             (ball_accelx200_circular_buffer_size-1)
#define loadcell_circular_buffer_size                           (100)
#define loadcell_circular_buffer_size_minus_1                   (loadcell_circular_buffer_size-1)
// **************************************************************************
// the globals

uint16_t start_logging_decimm = 1520; // 6 inches
uint_least16_t gCounter_updateGlobals = 0;
bool Flag_Latch_softwareUpdate = true;
CTRL_Handle ctrlHandle;
#ifdef CSM_ENABLE
#pragma DATA_SECTION(halHandle,"rom_accessed_data");
#endif
HAL_Handle halHandle;
#ifdef CSM_ENABLE
#pragma DATA_SECTION(gUserParams,"rom_accessed_data");
#endif
USER_Params gUserParams;
HAL_DacData_t gDacData;
HAL_PwmData_t gPwmData = {_IQ(0.0), _IQ(0.0), _IQ(0.0)};
HAL_AdcData_t gAdcData;
_iq gMaxCurrentSlope = _IQ(0.0);
#ifdef FAST_ROM_V1p6
CTRL_Obj *controller_obj;
#else
#ifdef CSM_ENABLE
#pragma DATA_SECTION(ctrl,"rom_accessed_data");
#endif
CTRL_Obj ctrl;				//v1p7 format
#endif
uint16_t gLEDcnt = 0;
ENC_Handle encHandle;
ENC_Obj enc;
ENC_Handle encHandle_1;
ENC_Obj enc_1;
uint32_t EncCount_1 = 0;
_iq EncAngle_iq_1 = _IQ(0.0);
// define cpu_time object and handle for CPU usage time calculation
CPU_TIME_Handle  cpu_timeHandle;
CPU_TIME_Obj     cpu_time;
uint32_t timer2Cnt = 0;
volatile MOTOR_Vars_t gMotorVars = MOTOR_Vars_INIT;
#ifdef FLASH
// Used for running BackGround in flash, and ISR in RAM
extern uint16_t *RamfuncsLoadStart, *RamfuncsLoadEnd, *RamfuncsRunStart;
#ifdef CSM_ENABLE
extern uint16_t *econst_start, *econst_end, *econst_ram_load;
extern uint16_t *switch_start, *switch_end, *switch_ram_load;
#endif
#endif
#ifdef DRV8301_SPI
// Watch window interface to the 8301 SPI
DRV_SPI_8301_Vars_t gDrvSpi8301Vars;
#endif
#ifdef DRV8305_SPI
// Watch window interface to the 8305 SPI
DRV_SPI_8305_Vars_t gDrvSpi8305Vars;
#endif
_iq gFlux_pu_to_Wb_sf;
_iq gFlux_pu_to_VpHz_sf;
_iq gTorque_Ls_Id_Iq_pu_to_Nm_sf;
_iq gTorque_Flux_Iq_pu_to_Nm_sf;
// **************************************************************************
bool forceangle = false;
_iq forced_elec_angle_pu = _IQ(0.0);
bool run_sensored = true;
bool setup_done = false;
bool allow_bar_stabilization = true;
uint16_t loadcell_front_tared_circular_buffer[loadcell_circular_buffer_size];
uint16_t loadcell_front_1_tared_circular_buffer[loadcell_circular_buffer_size];
uint16_t loadcell_rear_tared_circular_buffer[loadcell_circular_buffer_size];
uint16_t loadcell_rear_1_tared_circular_buffer[loadcell_circular_buffer_size];
uint16_t loadcell_circular_buffer_location = 0;
uint32_t loadcell_front_tared_ma_sum = 0;
uint32_t loadcell_front_1_tared_ma_sum = 0;
uint32_t loadcell_rear_tared_ma_sum = 0;
uint32_t loadcell_rear_1_tared_ma_sum = 0;
uint32_t ball_position_circular_buffer[ball_position_circular_buffer_size];
uint16_t ball_position_circular_buffer_location = 0;
uint16_t ball_position_decimm = 0;
uint32_t ball_position = 0;
uint32_t ball_position_ma_sum = 0;
uint32_t ball_position_ma_sum_prev = 0;
int16_t ball_velocityx10 = 0;
int16_t ball_velocityx10_ma_sum = 0;
int16_t ball_velocityx10_circular_buffer[ball_velocityx10_circular_buffer_size];
uint16_t ball_velocityx10_circular_buffer_location = 0;
int16_t ball_velocityx10_ma_sum_prev = 0;
int16_t ball_accelx200 = 0;
int16_t ball_accelx200_ma_sum = 0;
int16_t ball_accelx200_circular_buffer[ball_accelx200_circular_buffer_size];
uint16_t ball_accelx200_circular_buffer_location = 0;
uint16_t Rmax_decimm = 0;
uint16_t Rmin_decimm = 0;
uint16_t Rmax_other_motor_decimm = 0;
uint16_t Rmin_other_motor_decimm = 0;
uint16_t Tballs = 0;
uint16_t Tballs_other_motor = 0;
uint16_t Bballs = 0;
uint16_t Bballs_other_motor = 0;
float handle_position_mm = 0.0f;
float bar_position_mm = 0.0f;
uint32_t start_force_position_from_other_motor = 0;
uint16_t start_force_position_from_other_motor_recieved = 0;
uint16_t start_force_position_sent = 0;
int32_t ball_position_offset = 0;
int32_t delta_ball_position = 0;
int16_t delta_ball_position_decimm = 0;
bool tare_ball_position = false;
bool ball_position_tared = false;
uint16_t range_of_motion_states = ROM_Bottom_1;
bool set_started = false;
uint32_t Rmax = USER_MOTOR_START_COUNT;
uint32_t Rmin = USER_MOTOR_START_COUNT;
uint32_t Rmax_other_motor = USER_MOTOR_START_COUNT;
uint32_t Rmin_other_motor = USER_MOTOR_START_COUNT;
bool At_top = true;
bool At_bottom = true;
uint16_t Reps = 0;
bool tare_load_cells = false;
bool load_cells_tared = false;
uint32_t start_force_position = USER_MOTOR_START_COUNT;
uint16_t person_height_feet = 0;
uint16_t person_height_addn_inches = 0;
float person_height_decimm = 0.0f;
float start_force_fraction_person_height = 0.81f; // unique to overhead press
uint16_t start_force_position_decimm = platform_to_roller_decimm;
uint16_t start_force_position_decimm_used = platform_to_roller_decimm;
uint16_t start_force_position_other_motor_decimm = platform_to_roller_decimm;

float concentric_overloading_factor = 1.0f;
float concentric_overloading_factor_rate = 0.2f;
float concentric_overloading_speed_setting = 0.05f;
float bar_stabilization_factor = 1.0f;
float bar_stabilization_factor_rate = 0.002f;
bool concentric_overloading_factor_enable = false;
bool bar_stabilization_factor_enable = false;
bool bar_stabilization_factor_enable_manual = false;
bool dynamic_iso_perturbation_flag = false;
bool advanced_mode_flag = false;
bool force_enabled = false; // usually false;
bool led10_on_status = false;
bool gpio16_status = false;
bool user_switch_for_enable = false;
bool user_switch_for_relay_off = false;
bool undervoltage_shutdown_enable = false;
bool start_counter_enabled = true;
uint32_t force_enable_delay = 0;
uint32_t start_counter = 0;

uint16_t wt_centilb = wt_centilb_default;
uint16_t wt_centilb_other_motor = wt_centilb_default;
uint16_t advanced_wt_centilb = wt_centilb_default;
uint16_t advanced_wt_centilb_other_motor = wt_centilb_default;
float advanced_wt_lb = wt_lb_default;
float wt_lb = wt_lb_default;
float wt_lb_set = wt_lb_default;
float wt_lb_slewed_set = wt_lb_default;
float wt_lb_actually_set = wt_lb_default;
float wt_lb_actually_actually_set = wt_lb_default;
float wt_lb_actually_actually_set_slewed = wt_lb_default;
float wt_lb_correction_inertia_accel = 0.0;
float wt_lb_correction_inertia_accel_max_limit = 10.0;
bool danger_flag = false;
float wt_lb_actually_set_measured = wt_lb_default;
float wt_lb_desired = wt_lb_default;
float slew_while_increasing_weight = 0.002;
float slew_while_decreasing_weight = 0.002;
float slew_while_increasing_weight_friction = 0.001;
float slew_while_decreasing_weight_friction = 0.001;
uint16_t wt_centilb_measured = wt_centilb_default;
uint16_t wt_centilb_measured_other_motor = wt_centilb_default;
uint16_t Set_wt_centilb_other_motor = 0;
uint16_t Set_advanced_wt_centilb_other_motor = wt_centilb_default;

_iq IqRef_pu_pos_max = _IQ(IqRef_pu_pos_max_init);
_iq IqRef_pu_neg_max = _IQ(IqRef_pu_neg_max_init);

bool log_sample = false;
_iq EncAngle_iq_log = _IQ(0.0);
_iq BEMFAngle_iq_log = _IQ(0.0);
float log_angle_speed_setting = 0.5f;
uint16_t Status_motor = 0;
uint16_t Status_other_motor = 0;
uint16_t position_packet_read_on_serial = 0;
uint16_t position_packet_sent_on_serial = 0;
uint16_t send_packet_counter = 0;
uint16_t send_packet_type = Send_Position_Packet_1;
SCI_FifoStatus_e TxFifoStatusSCIB;
SCI_FifoStatus_e TxFifoStatusSCIA;
uint16_t packet_send[3] = {0, 0, 0};
uint16_t packet_recieved[3] = {0, 0, 0};
uint16_t packet_recieved_1[11] = {0,0,0,0,0,0,0,0,0,0,0};
uint16_t packet_send_1[10] = {0,0,0,0,0,0,0,0,0,0};
uint16_t tempArr[7] = {0,0,0,0,0,0,0};
uint16_t CRCByte = 0;
uint16_t CRC16bit_1 = 0;
uint16_t CRC16bit_2 = 0;
uint16_t checkCRCByte = 0;
uint32_t ball_position_other_motor = 0;
uint16_t ball_position_other_motor_decimm = 0;
uint32_t ball_position_other_motor_recieved = 0;
uint16_t Status_flags_other_motor = 0 ;
SCI_FifoStatus_e RxFifoStatusSCIB;
SCI_FifoStatus_e RxFifoStatusSCIA;
int16_t accel_mm_per_sec_sq = 0;
int16_t velocity_mm_per_sec = 0;
int16_t accel_other_motor_mm_per_sec_sq = 0;
int16_t velocity_other_motor_mm_per_sec = 0;
uint16_t status_smart_platform = 0;
uint16_t status_smart_platform_other_motor = 0;
uint16_t status_smart_platform_left_test = 0;
uint16_t status_smart_platform_right_test = 0;
uint16_t loadcell_front_tared_lbx10_14bit_other_motor = 0;
uint16_t loadcell_front_1_tared_lbx10_14bit_other_motor = 0;
uint16_t loadcell_rear_tared_lbx10_14bit_other_motor = 0;
uint16_t loadcell_rear_1_tared_lbx10_14bit_other_motor = 0;
uint16_t Loadcell_type = 0;
uint16_t Loadcell_type_other_motor = 0;
uint16_t Loadcell_16bit = 0;
uint16_t Loadcell_16bit_other_motor = 0;
uint16_t advanced_mode_status_flags = 0;
uint16_t advanced_mode_status_flags_sent_to_other_motor = 0;
uint16_t advanced_mode = 0;
uint16_t advanced_mode_gain = 0;
bool new_ball_position_other_motor_recieved = false;
bool enable_serial_exchange = true;
uint16_t send_packet_over_serial_counter = 0;
uint16_t send_packet_over_serial_counter_other_motor = 0;
uint16_t read_packet_over_serial_counter = 0;
int16_t delta_send_minus_read_packet_over_serial_counter = 0;
uint16_t packet_send_counter = 0;
uint16_t packet_send_counter_check=0;
uint16_t packet_send_counter_check_prev = 0;
uint16_t packet_send_counter_check_delta = 0;
uint16_t packets_lost = 0;
uint16_t test_counter = 0;
uint16_t test_counter1 = 0;
uint16_t test_counter2 = 0;
uint16_t test_counter3 = 0;
uint16_t test_counter4 = 0;
uint16_t test_counter5 = 0;
uint16_t test_counter6 = 0;
uint16_t test_counter7 = 0;
uint16_t test_counter8 = 0;
uint16_t test_counter9 = 0;
uint16_t test_counter10 = 0;
uint64_t test_enable_serial_exchanged_called = 0;
uint16_t test_no_bytes_in_Rx_buffer = 0;
uint16_t test_1_byte_in_Rx_buffer = 0;
uint16_t test_2_bytes_in_Rx_buffer = 0;
uint16_t test_3_bytes_in_Rx_buffer = 0;
uint16_t test_4_bytes_in_Rx_buffer = 0;
uint64_t packet_sent = 0;
uint16_t dc_bus_current_bits = 0;
float dc_bus_current_inV = 0.0f;
float dc_bus_current_inA = 0.0f;
float dcbus_current_sensor_gain = 5.0f; // for Ti # TMCS1108A1BQDR 50mv/A  +-29A range at 3.3v Vs
//float dcbus_current_sensor_gain = 10.0f; // for TI # TMCS1101A2BQDRQ1
//float dcbus_current_sensor_gain = 15.151515f; // for Allegro # ACS725LLCTR-20AB-T
//float dcbus_current_sensor_offset = 1.644f;
float dcbus_current_sensor_offset = 1.65f;
float min_balance_fraction = 0.5f;
uint16_t loadcell_front = 0;
uint16_t loadcell_rear  = 0;
int16_t loadcell_front_offset = 0;
int16_t loadcell_rear_offset  = 0;
int16_t loadcell_front_1_offset = 0;
int16_t loadcell_rear_1_offset  = 0;
uint16_t loadcell_front_tared = 0;
float loadcell_front_tared_lb = 0.0f;
uint16_t loadcell_front_tared_lbx10_14bit = 0;
uint16_t loadcell_rear_tared  = 0;
float loadcell_rear_tared_lb  = 0.0f;
uint16_t loadcell_rear_tared_lbx10_14bit = 0;
uint16_t loadcell_front_1_tared = 0;
float loadcell_front_1_tared_lb = 0.0f;
uint16_t loadcell_front_1_tared_lbx10_14bit = 0;
uint16_t loadcell_rear_1_tared  = 0;
float loadcell_rear_1_tared_lb  = 0.0f;
uint16_t loadcell_rear_1_tared_lbx10_14bit = 0;
float loadcell_all_plus_tared_lb = 0.0f;
uint32_t loadcell_diff_window  = 100000;
float non_zero_load_on_front_and_rear_loadcell_lb  = 20.0f;
uint16_t loadcell_front_1 = 0;
uint16_t loadcell_rear_1  = 0;
uint16_t battery_thermistor = 0;
uint16_t motor_thermistor = 0;
float loadcell_front_inlb = 0.0f;
float loadcell_rear_inlb  = 0.0f;
float loadcell_front_plus_rear_inlb = 0.0f;
float loadcell_delta_front_rear_inlb = 0.0f;
float loadcell_delta_front_rear_fraction = 0.0f;
float loadcell_delta_front_rear_1_fraction = 0.0f;
bool platform_force_balanced = false;
bool smart_platform_enabled = false;
uint32_t platform_force_balanced_counter = 0;
bool user_not_standing_on_platform = true;
bool front_heavier_than_rear = false;
bool rear_heavier_than_front = false;
bool front_almost_same_heavy_as_rear = false;
uint16_t advanced_mode_other_motor = 0;
uint16_t advanced_mode_gain_other_motor = 0;
uint16_t advanced_mode_status_flags_other_motor = 0;
uint16_t advanced_mode_status_flags_input_over_ble = 0;
uint16_t status_flags_input_over_ble = 0;
uint16_t loadcell_right_type = 0;
uint16_t loadcell_left_type = 0;
uint16_t loadcell_front_or_rear_left_or_right = 0;
uint16_t status_smart_platform_left_and_right = 0;
bool pause_sending_upstream_packet_on_ble = false;
uint32_t ble_delay_counter = 0;
uint16_t ble_response_array[ble_response_array_size];
uint16_t ble_response_array_counter = 0;
uint16_t ble_recieve_packet_array[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
uint16_t ble_recieve_packet_array_counter = 0;
uint16_t ble_packet_recieved = 0;
uint32_t ble_packet_sent_counter = 0;
bool ble_on_serial = true;
bool switch_ble_on_serial = false;
bool disconnect_ble_central_host = false;
bool disconnect_ble_after_60s = false;
uint16_t disconnect_ble_central_host_counter = 0;
uint16_t crc16_send_packet = 0xFFFF;
uint16_t crc16_recieve_packet = 0xFFFF;
uint16_t crc16_check = 0;
uint16_t status_flags = 0;
uint16_t status_flags_input_over_ble_left = 0;
uint16_t status_flags_input_over_ble_right = 0;
uint16_t position_left = 0;
uint16_t position_right = 0;
uint16_t start_force_position_setting_left = platform_to_roller_mm;
uint16_t start_force_position_setting_right = platform_to_roller_mm;
uint16_t start_force_position_setting_input_over_ble = 0;
uint16_t force_left_centiLbs = 0;
uint16_t nominal_force_setting_left_centiLbs = 0;
uint16_t nominal_force_setting_input_over_ble_centiLbs = wt_centilb_default;
uint16_t advanced_force_setting_input_over_ble_centiLbs = wt_centilb_default;
uint16_t force_right_centiLbs = 0;
uint16_t nominal_force_setting_right_centiLbs = 0;
uint16_t nominal_force_setting_input_over_ble_right_centiLbs = wt_centilb_default;
uint16_t loadcell_left_lbx10 = 0;
uint16_t loadcell_right_lbx10 = 0;
uint16_t send_packet_over_ble_steps = send_packet_over_ble_gather_data_step0;
uint16_t read_packet_over_ble_steps = read_packet_over_ble_step0;
uint32_t update_counter = 1;
uint16_t ack_counter = 0;
uint16_t name_match_counter = 0;
uint16_t byte_read = 0;
uint16_t byte_read_prev = 0;
uint16_t counter_send_ble_packet = 0;
uint16_t counter_send_ble_packet_max = 250; // 300 for 10khz = 33.33hz (30ms), 250 for 10khz = 40hz (25ms)
uint32_t ms_since_last_ble_packet_from_App = 0;
bool switching_between_ble_and_usb_serial_allowed = false;
bool ble_central_host_connected = false;
bool serial_central_host_connected = false;
bool reset_if_no_consistent_downstream_packets = true;

uint16_t ms_counter = 1;
uint32_t timestamp = 0;
bool automate_startup = true;
bool startup_process_done = false;
bool first_tare_ball_position_done = false;
uint16_t tare_counter = 0;
uint16_t tare_counter_ball_position_reset = 40000;
uint16_t battery_voltage_centiV = 0;
int16_t battery_current_centiA = 0;
uint32_t muscle_strain = 0;
float battery_voltage_V = 0.0f;
float Battery_Power_W = 0.0f;
uint32_t log_array_pos = 0;
uint16_t log_counter = 1;
uint16_t log_counter_max = 10;
bool log_array = false;
bool log_array_start = false;
bool log_init = true;
//uint32_t log_ball_position_ma_sum[LOG_ARRAY_SIZE];
//int16_t log_ball_velocityx10_ma_sum[LOG_ARRAY_SIZE];
//int16_t log_ball_accelx200_ma_sum[LOG_ARRAY_SIZE];
//float log_wt_lb_correction_inertia_accel[LOG_ARRAY_SIZE];
//float log_wt_lb[LOG_ARRAY_SIZE];
//uint32_t log_ball_EncCount[LOG_ARRAY_SIZE] ;
//uint32_t log_ball_EncCount_1[LOG_ARRAY_SIZE] ;
int32_t log_EncCount_diff[LOG_ARRAY_SIZE] ;
//uint16_t log_EncCount_1[LOG_ARRAY_SIZE] ;
//uint16_t log_EncCount[LOG_ARRAY_SIZE] ;
//uint16_t log_EncCount_SPI[LOG_ARRAY_SIZE] ;
float log_EncAngle_diff[LOG_ARRAY_SIZE] ;
bool solenoid_lock_flag_input = false; // solenoid is on, brake released
float duty_cycle = 0.0;
float duty_cycle_10v = 0.0;
float duty_cycle_5v = 0.0;
bool enable_start_set_using_lock_bit = true;
bool enable_solenoid_brake = true;
bool solenoid_brake_released = false;
uint16_t enable_solenoid_brake_counter = 0;
uint16_t enable_solenoid_brake_counter_max = 1000; // 1000 x 100us = 100ms. 500 * 100us = 50ms was enough when tested experimentally.
bool bar_attachment_connected = false;
bool advanced_force_mode_enabled = false;
bool smart_barbell_safety_triggered = false;
bool smart_barbell_enabled = false;
bool drv8301_spi_write_enable = true;
bool drv8301_spi_read_enable = true;
bool led_display_enabled = false;
bool button_enabled = false;
bool led_display_setup_notdone = true;
bool drv8301_setup_notdone = false;
bool relay_switch_enabled = true;
bool state_gpo_44_relay_switch = false;
uint16_t relay_switch_counter = 0;
bool usb_serial_disconnected = true;
bool usb_serial_connected_step1 = false;
bool usb_serial_flag = false;
bool usb_serial_comms_allowed = false;
bool state_gpio50 = true; // only for PB2
bool state_gpio42 = true;
bool state_gpio41 = true;
bool state_gpio40 = true;
bool state_gpio11 = true;
bool state_gpio9 = true;
bool state_gpio7 = true;
bool charger_disconnected = true;
bool force_enabled_other_motor = false;
bool serial_exchange_working_in_both_directions = true;
bool ball_stop_down = false;
bool manually_set_weight = false;
bool enable_friction_compensation = false;
bool enable_friction_compensation_force = true;
bool enable_inertia_compensation_force = true;
bool enable_inertia_compensation_log = true;
bool enable_inertia_compensation = false;
bool ball_accelx200_circular_buffer_zeroing_done = false;
bool ball_velocityx10_circular_buffer_zeroing_done = false;;
bool ball_position_circular_buffer_zeroing_done = false;
bool loadcell_circular_buffer_zeroing_done = false;
_iq rotor_inertia_factor_eccentric_decel_iq  = _IQ(0.0025) ;
_iq rotor_inertia_factor_eccentric_accel_iq  = _IQ(0.0);
_iq rotor_inertia_factor_concentric_decel_iq = _IQ(0.0025) ;
_iq rotor_inertia_factor_concentric_accel_iq = _IQ(0.0);
_iq IqRef_pu = _IQ(0.0);
_iq IqRef_pu_corr_inertia_accel = _IQ(0.0);
_iq iq_var_min_limit = _IQ(0.0);
_iq iq_var_max_limit = _IQ(0.0);
bool test_load_cell = false;
bool read_encoder_spiA = true;
uint16_t read_16bit_SPIA_temp = 0;
uint16_t Encoder_count = 0;
uint16_t Encoder_count_prev = 0;
int16_t Encoder_diff = 0;
int16_t turns = 5;
uint32_t Encoder_count_multiturn = 0;
uint32_t Encoder_count_multiturn_corr = 0;
uint16_t Encoder_count_multiturn_offset = 0;
uint32_t SPIA_read_framming_error_counter = 0;
uint16_t first_few_samples = 0;
//uint32_t SPIA_read_counter = 0;
//uint16_t HAL_readSPIA_counter = 0;
//float SPIA_read_framming_error_percentage = 0.0;
//uint16_t Encoder_address_to_be_read = 0x3FFF;
//uint16_t DIAAGC_AGC_val = 0;
//uint16_t DIAAGC_ERR_val = 0;
//uint16_t CMAG_val = 0;
//uint16_t CORDICANG_val = 0;
//uint16_t DAECANG_val = 0;
//uint16_t SETTINGS1_val = 0;
//uint16_t SETTINGS2_val = 0;
//bool comp_l_error_en_flag = false;
//bool comp_h_error_en_flag = false;
//uint16_t ZPOSM_val = 0;
//uint16_t ZPOSL_val = 0;
//uint16_t ZPOS_val = 0;

// the functions
uint16_t getCRCArray(uint16_t message[], uint16_t length)
{
    uint16_t i, j, crc = 0;

    for (i = 0; i < length; i++)
    {
        crc ^= message[i];
        for (j = 0; j < 8; j++)
        {
            if (crc & 1)
            crc ^= 0x0091;
            crc >>= 1;
        }
    }
    crc = crc & 0x00FF;
    return crc;
} // end of getCRCArray() function

uint16_t getCRC16(uint16_t byte, uint16_t crc16_init) // input elements is byte sized ie 0x00XX , crc16_init = 0xFFFF for first byte of array
{
    uint16_t j;
    crc16_init = (crc16_init ^ byte) << 8;
    for (j = 0; j < 8; ++j)
    {
        if (crc16_init & 0x8000)
            crc16_init = (crc16_init << 1) ^ 0x8005;
        else
            crc16_init = crc16_init << 1;
    }

    return crc16_init;
}// end of getCRC16() function

void send_packet_over_serial(HAL_Handle handle)
{
    TxFifoStatusSCIB = HAL_getTxFifoStatusSCIB(handle);
    if (TxFifoStatusSCIB == SCI_FifoStatus_Empty)
    {
        switch(send_packet_type)
        {
        case Send_Position_Packet_1 :
            //HAL_toggleGpio(halHandle,GPIO_Number_10);
            packet_send[0] = Position_Packet_Header;
            packet_send[1] = (ball_position_decimm >> 8) & 0x00FF ;
            packet_send[2] = ball_position_decimm & 0x00FF ;
            send_packet_type = Send_Status_Packet;
            break;
        case Send_Status_Packet :
            packet_send[0] = Status_Packet_Header;
            packet_send[1] = advanced_mode_status_flags_sent_to_other_motor & 0x00FF ;
            packet_send[2] = Status_motor & 0x00FF ;
            send_packet_type = Send_MotorForce_Setting;
            break;
        case Send_MotorForce_Setting :
            packet_send[0] = MotorForce_Setting_Header;
            packet_send[1] = (wt_centilb >> 8) & 0x00FF ;
            packet_send[2] = wt_centilb & 0x00FF ;
            send_packet_type = Send_start_force_position_Setting;
            break;
        case Send_start_force_position_Setting :
            packet_send[0] = start_force_position_Setting_Header;
            packet_send[1] = (start_force_position_decimm_used >> 8) & 0x00FF ;
            packet_send[2] = start_force_position_decimm_used & 0x00FF ;
            send_packet_type = Send_MotorAdvancedForce_Setting;
            break;
        case Send_MotorAdvancedForce_Setting :
            packet_send[0] = MotorAdvancedForce_Setting_Header;
            packet_send[1] = (advanced_wt_centilb >> 8) & 0x00FF ;
            packet_send[2] = advanced_wt_centilb  & 0x00FF ;
            send_packet_type = Send_Position_Packet_2;
            break;
        case Send_Position_Packet_2 :
            //HAL_toggleGpio(halHandle,GPIO_Number_10);
            packet_send[0] = Position_Packet_Header;
            packet_send[1] = (ball_position_decimm >> 8) & 0x00FF ;
            packet_send[2] = ball_position_decimm & 0x00FF ;
            send_packet_type = Send_Accel;
            break;
        case Send_Accel :
            packet_send[0] = Accel_Header;
            packet_send[1] = (accel_mm_per_sec_sq >> 8) & 0x00FF ;
            packet_send[2] =  accel_mm_per_sec_sq & 0x00FF ;
            send_packet_type = Send_Velocity;
            break;
        case Send_Velocity :
            packet_send[0] = Velocity_Header;
            packet_send[1] = (velocity_mm_per_sec >> 8) & 0x00FF ;
            packet_send[2] =  velocity_mm_per_sec & 0x00FF ;
            send_packet_type = Send_ROM_min;
            break;
        case Send_ROM_min :
            packet_send[0] = ROM_min_Header;
            packet_send[1] = (Rmin_decimm >> 8) & 0x00FF ;
            packet_send[2] = Rmin_decimm  & 0x00FF ;
            send_packet_type = Send_ROM_max ;
            break;
        case Send_ROM_max :
            packet_send[0] = ROM_max_Header;
            packet_send[1] = (Rmax_decimm >> 8) & 0x00FF ;
            packet_send[2] =  Rmax_decimm & 0x00FF ;
            send_packet_type = Send_Position_Packet_3;
            break;
        case Send_Position_Packet_3 :
            //HAL_toggleGpio(halHandle,GPIO_Number_10);
            packet_send[0] = Position_Packet_Header;
            packet_send[1] = (ball_position_decimm >> 8) & 0x00FF ;
            packet_send[2] = ball_position_decimm & 0x00FF ;
            send_packet_type = Send_Tballs_Bballs;
            break;
        case Send_Tballs_Bballs :
            packet_send[0] = Tballs_Bballs_Header;
            packet_send[1] =  Tballs & 0x00FF ;
            packet_send[2] =  Bballs & 0x00FF ;
            send_packet_type = Send_MotorForce_Measured;
            break;
        case Send_MotorForce_Measured :
            packet_send[0] = MotorForce_Measured_Header;
            packet_send[1] = (wt_centilb_measured >> 8) & 0x00FF ;
            packet_send[2] = wt_centilb_measured & 0x00FF ;
            send_packet_type = Send_Loadcell_packet;
            break;
        case Send_Loadcell_packet :
            packet_send[0] = Loadcell_packet_header;
            switch(Loadcell_type)
            {
            case 0 :
                Loadcell_16bit = loadcell_front_tared_lbx10_14bit;
                Loadcell_type = 1;
                break;
            case 1 :
                Loadcell_16bit = loadcell_front_1_tared_lbx10_14bit + 0b0100000000000000;
                Loadcell_type = 2;
                break;
            case 2 :
                Loadcell_16bit = loadcell_rear_tared_lbx10_14bit + 0b1000000000000000;
                Loadcell_type = 3;
                break;
            case 3 :
                Loadcell_16bit = loadcell_rear_1_tared_lbx10_14bit + 0b1100000000000000;
                Loadcell_type = 0;
                break;
            default :
                break;
            }
            packet_send[1] = (Loadcell_16bit >> 8) & 0x00FF ;
            packet_send[2] = Loadcell_16bit  & 0x00FF ;
            send_packet_type = Send_send_packet_over_serial_counter;
            break;
        case Send_send_packet_over_serial_counter :
            packet_send[0] = send_packet_over_serial_counter_header;
            packet_send[1] = (send_packet_over_serial_counter >> 8) & 0x00FF ;
            packet_send[2] = send_packet_over_serial_counter  & 0x00FF ;
            send_packet_over_serial_counter++;
            send_packet_type = Send_Position_Packet_1;
            break;
        default :
            break;
        }
        CRCByte = getCRCArray(packet_send,3);
        HAL_writeSCIBFIFO(handle,packet_send[0]);
        HAL_writeSCIBFIFO(handle,packet_send[1]);
        HAL_writeSCIBFIFO(handle,packet_send[2]);
        HAL_writeSCIBFIFO(handle,CRCByte);
    }
    return;
}// end of send_packet_over_serial() function

bool isValidHeader(uint16_t header)
{
    bool flag = true;
    switch(header)
    {
    case Position_Packet_Header :
        break;
    case Status_Packet_Header :
        break;
    case MotorForce_Measured_Header :
        break;
    case MotorForce_Setting_Header :
        break;
    case start_force_position_Setting_Header :
        break;
    case MotorAdvancedForce_Setting_Header :
        break;
    case Accel_Header :
        break;
    case Velocity_Header :
        break;
    case ROM_max_Header :
        break;
    case ROM_min_Header :
        break;
    case Tballs_Bballs_Header :
        break;
    case Loadcell_packet_header :
        break;
    case send_packet_over_serial_counter_header :
        break;
    default:
        flag = false;
        break;
    }
    return flag;
} // end of isValidHeader() function

void read_valid_packet(uint16_t packet[])
{
    switch(packet[0])
    {
        case Position_Packet_Header :
            ball_position_other_motor_recieved = (packet[1] << 8) + packet[2];
            HAL_toggleGpio(halHandle,GPIO_Number_11);
            new_ball_position_other_motor_recieved = true;
            break;
        case Status_Packet_Header :
            Status_flags_other_motor = (packet[1]<<8) + packet[2];
            break;
        case MotorForce_Measured_Header :
            wt_centilb_measured_other_motor = (packet[1]<<8) + packet[2];
            break;
        case MotorForce_Setting_Header :
            Set_wt_centilb_other_motor = (packet[1]<<8) + packet[2];
            if(!serial_exchange_working_in_both_directions)
            {
                if(Set_wt_centilb_other_motor == wt_centilb_default)
                    serial_exchange_working_in_both_directions = true;
            }
            break;
        case start_force_position_Setting_Header :
            start_force_position_other_motor_decimm = (packet[1]<<8) + packet[2];
            break;
        case MotorAdvancedForce_Setting_Header :
            Set_advanced_wt_centilb_other_motor = (packet[1]<<8) + packet[2];
            break;
        case Accel_Header:
            accel_other_motor_mm_per_sec_sq = (packet[1]<<8) + packet[2];
            break;
        case Velocity_Header:
            velocity_other_motor_mm_per_sec = (packet[1]<<8) + packet[2];
            break;
        case ROM_min_Header:
            Rmin_other_motor_decimm = (packet[1]<<8) + packet[2];
            break;
        case ROM_max_Header:
            Rmax_other_motor_decimm = (packet[1]<<8) + packet[2];
            break;
        case Tballs_Bballs_Header:
            Tballs_other_motor = packet[1];
            Bballs_other_motor = packet[2];
            break;
        case Loadcell_packet_header:
            Loadcell_16bit_other_motor = (packet[1]<<8) + packet[2];
            Loadcell_type_other_motor = Loadcell_16bit_other_motor >> 14;
            switch(Loadcell_type_other_motor)
            {
            case 0 :
                if(!test_load_cell)
                    loadcell_front_tared_lbx10_14bit_other_motor = Loadcell_16bit_other_motor & 0b0011111111111111;
                break;
            case 1 :
                if(!test_load_cell)
                    loadcell_front_1_tared_lbx10_14bit_other_motor = Loadcell_16bit_other_motor & 0b0011111111111111;
                break;
            case 2 :
                if(!test_load_cell)
                    loadcell_rear_tared_lbx10_14bit_other_motor = Loadcell_16bit_other_motor & 0b0011111111111111;
                break;
            case 3 :
                if(!test_load_cell)
                    loadcell_rear_1_tared_lbx10_14bit_other_motor = Loadcell_16bit_other_motor & 0b0011111111111111;
                break;
            default :
                break;
            }
            break;
        case send_packet_over_serial_counter_header :
            send_packet_over_serial_counter_other_motor = (packet[1]<<8) + packet[2];
            read_packet_over_serial_counter++;
            delta_send_minus_read_packet_over_serial_counter = send_packet_over_serial_counter_other_motor - read_packet_over_serial_counter;
            break;
        default:
            break;
    }
    return ;
}   // end of read_valid_packet() function

void check_for_packet_received_over_serial(HAL_Handle handle)
{
    RxFifoStatusSCIB = HAL_getRxFifoStatusSCIB(handle);
    switch(RxFifoStatusSCIB)
      {
            case SCI_FifoStatus_Empty : // no bytes in the RX FIFO
                test_no_bytes_in_Rx_buffer++;
                break;

            case SCI_FifoStatus_1_Word :  // extract that 1 byte in the RX FIFO
               test_1_byte_in_Rx_buffer++;
               tempArr[3] = (HAL_readSCIBFIFO(handle) & 0x00FF);
               if (isValidHeader(tempArr[0]))
               {
                   packet_recieved[0] = tempArr[0] & 0x00FF ;
                   packet_recieved[1] = tempArr[1] & 0x00FF ;
                   packet_recieved[2] = tempArr[2] & 0x00FF ;
                   CRCByte            = tempArr[3] & 0x00FF ;
                   if(getCRCArray(packet_recieved,3) == CRCByte)
                   {
                       read_valid_packet(packet_recieved);
                       tempArr[0] = 0;
                       tempArr[1] = 0;
                       tempArr[2] = 0;
                       tempArr[3] = 0;
                   }
               }
               tempArr[0] = tempArr[1];
               tempArr[1] = tempArr[2];
               tempArr[2] = tempArr[3];
               break;

           case SCI_FifoStatus_2_Words : // extract that 2 bytes in the RX FIFO
               test_2_bytes_in_Rx_buffer++;
               tempArr[3] = (HAL_readSCIBFIFO(handle) & 0x00FF);
               tempArr[4] = (HAL_readSCIBFIFO(handle) & 0x00FF);
               if (isValidHeader(tempArr[0]))
               {
                   packet_recieved[0] = tempArr[0] & 0x00FF ;
                   packet_recieved[1] = tempArr[1] & 0x00FF ;
                   packet_recieved[2] = tempArr[2] & 0x00FF ;
                   CRCByte            = tempArr[3] & 0x00FF ;
                   if(getCRCArray(packet_recieved,3) == CRCByte)
                   {
                       read_valid_packet(packet_recieved);
                       tempArr[0] = 0;
                       tempArr[1] = 0;
                       tempArr[2] = 0;
                       tempArr[3] = 0;
                   }
               }
               else if (isValidHeader(tempArr[1]))
               {
                   packet_recieved[0] = tempArr[1] & 0x00FF ;
                   packet_recieved[1] = tempArr[2] & 0x00FF ;
                   packet_recieved[2] = tempArr[3] & 0x00FF ;
                   CRCByte            = tempArr[4] & 0x00FF ;
                   if(getCRCArray(packet_recieved,3) == CRCByte)
                   {
                       read_valid_packet(packet_recieved);
                       tempArr[1] = 0;
                       tempArr[2] = 0;
                       tempArr[3] = 0;
                       tempArr[4] = 0;
                   }
               }
               tempArr[0] = tempArr[2];
               tempArr[1] = tempArr[3];
               tempArr[2] = tempArr[4];
               break;

           case SCI_FifoStatus_3_Words : // extract that 3 bytes in the RX FIFO
               test_3_bytes_in_Rx_buffer++;
               tempArr[3] = (HAL_readSCIBFIFO(handle) & 0x00FF);
               tempArr[4] = (HAL_readSCIBFIFO(handle) & 0x00FF);
               tempArr[5] = (HAL_readSCIBFIFO(handle) & 0x00FF);
               if (isValidHeader(tempArr[0]))
               {
                   packet_recieved[0] = tempArr[0] & 0x00FF ;
                   packet_recieved[1] = tempArr[1] & 0x00FF ;
                   packet_recieved[2] = tempArr[2] & 0x00FF ;
                   CRCByte            = tempArr[3] & 0x00FF ;
                   if(getCRCArray(packet_recieved,3) == CRCByte)
                   {
                       read_valid_packet(packet_recieved);
                       tempArr[0] = 0;
                       tempArr[1] = 0;
                       tempArr[2] = 0;
                       tempArr[3] = 0;
                   }
               }
               else if (isValidHeader(tempArr[1]))
               {
                   packet_recieved[0] = tempArr[1] & 0x00FF ;
                   packet_recieved[1] = tempArr[2] & 0x00FF ;
                   packet_recieved[2] = tempArr[3] & 0x00FF ;
                   CRCByte            = tempArr[4] & 0x00FF ;
                   if(getCRCArray(packet_recieved,3) == CRCByte)
                   {
                       read_valid_packet(packet_recieved);
                       tempArr[1] = 0;
                       tempArr[2] = 0;
                       tempArr[3] = 0;
                       tempArr[4] = 0;
                   }
               }
               else if (isValidHeader(tempArr[2]))
               {
                   packet_recieved[0] = tempArr[2] & 0x00FF ;
                   packet_recieved[1] = tempArr[3] & 0x00FF ;
                   packet_recieved[2] = tempArr[4] & 0x00FF ;
                   CRCByte            = tempArr[5] & 0x00FF ;
                   if(getCRCArray(packet_recieved,3) == CRCByte)
                   {
                       read_valid_packet(packet_recieved);
                       tempArr[2] = 0;
                       tempArr[3] = 0;
                       tempArr[4] = 0;
                       tempArr[5] = 0;
                   }
               }
               tempArr[0] = tempArr[3];
               tempArr[1] = tempArr[4];
               tempArr[2] = tempArr[5];
               break;

           case SCI_FifoStatus_4_Words : // extract that 4 bytes in the RX FIFO
               test_4_bytes_in_Rx_buffer++;
               tempArr[3] = (HAL_readSCIBFIFO(handle) & 0x00FF);
               tempArr[4] = (HAL_readSCIBFIFO(handle) & 0x00FF);
               tempArr[5] = (HAL_readSCIBFIFO(handle) & 0x00FF);
               tempArr[6] = (HAL_readSCIBFIFO(handle) & 0x00FF);
               if (isValidHeader(tempArr[0]))
               {
                   packet_recieved[0] = tempArr[0] & 0x00FF ;
                   packet_recieved[1] = tempArr[1] & 0x00FF ;
                   packet_recieved[2] = tempArr[2] & 0x00FF ;
                   CRCByte            = tempArr[3] & 0x00FF ;
                   if(getCRCArray(packet_recieved,3) == CRCByte)
                   {
                       read_valid_packet(packet_recieved);
                       tempArr[0] = 0;
                       tempArr[1] = 0;
                       tempArr[2] = 0;
                       tempArr[3] = 0;
                   }
               }
               else if (isValidHeader(tempArr[1]))
               {
                   packet_recieved[0] = tempArr[1] & 0x00FF ;
                   packet_recieved[1] = tempArr[2] & 0x00FF ;
                   packet_recieved[2] = tempArr[3] & 0x00FF ;
                   CRCByte            = tempArr[4] & 0x00FF ;
                   if(getCRCArray(packet_recieved,3) == CRCByte)
                   {
                       read_valid_packet(packet_recieved);
                       tempArr[1] = 0;
                       tempArr[2] = 0;
                       tempArr[3] = 0;
                       tempArr[4] = 0;
                   }
               }
               else if (isValidHeader(tempArr[2]))
               {
                   packet_recieved[0] = tempArr[2] & 0x00FF ;
                   packet_recieved[1] = tempArr[3] & 0x00FF ;
                   packet_recieved[2] = tempArr[4] & 0x00FF ;
                   CRCByte            = tempArr[5] & 0x00FF ;
                   if(getCRCArray(packet_recieved,3) == CRCByte)
                   {
                       read_valid_packet(packet_recieved);
                       tempArr[2] = 0;
                       tempArr[3] = 0;
                       tempArr[4] = 0;
                       tempArr[5] = 0;
                   }
               }
               else if (isValidHeader(tempArr[3]))
               {
                   packet_recieved[0] = tempArr[3] & 0x00FF ;
                   packet_recieved[1] = tempArr[4] & 0x00FF ;
                   packet_recieved[2] = tempArr[5] & 0x00FF ;
                   CRCByte            = tempArr[6] & 0x00FF ;
                   if(getCRCArray(packet_recieved,3) == CRCByte)
                   {
                       read_valid_packet(packet_recieved);
                       tempArr[3] = 0;
                       tempArr[4] = 0;
                       tempArr[5] = 0;
                       tempArr[6] = 0;
                   }
               }
               tempArr[0] = tempArr[4];
               tempArr[1] = tempArr[5];
               tempArr[2] = tempArr[6];
               break;
           default :
               break;
      }
    return;
}   // end of check_for_packet_over_serial() function

void send_packet_over_ble(HAL_Handle handle)
{
    switch(send_packet_over_ble_steps)
    {
    case send_packet_over_ble_gather_data_step0 :
        crc16_send_packet = 0xFFFF;
        ble_response_array_counter = 0;
        if(pause_sending_upstream_packet_on_ble)
            send_packet_over_ble_steps = send_packet_over_ble_bypass_step2 ;
        else
            send_packet_over_ble_steps = send_packet_over_ble_gather_data_step1 ;
        break;
    case send_packet_over_ble_gather_data_step1 :
        ble_response_array[0] = (send_packet_over_ble_header >> 8) & 0x00FF ;
        ble_response_array[1] = send_packet_over_ble_header & 0x00FF ;
        ble_response_array[2] = (ball_position_decimm>> 8) & 0x00FF ;
        ble_response_array[3] = ball_position_decimm & 0x00FF ;
        ble_response_array[4] = (ball_position_other_motor_decimm >> 8) & 0x00FF ;
        ble_response_array[5] = ball_position_other_motor_decimm & 0x00FF ;
        ble_response_array[6] = (wt_centilb_measured >> 8) & 0x00FF ;
        ble_response_array[7] = wt_centilb_measured & 0x00FF ;
        ble_response_array[8] = (wt_centilb_measured_other_motor >> 8) & 0x00FF ;
        ble_response_array[9] = wt_centilb_measured_other_motor & 0x00FF ;
        ble_response_array[10] = Status_motor & 0x00FF;
        ble_response_array[11] = Status_other_motor & 0x00FF ;
#ifdef FakePodium_Rivu
        ble_response_array[11] = Status_motor & 0x00FF ;
#endif
        ble_response_array[12] = (battery_voltage_centiV >> 8) & 0x00FF ;
        ble_response_array[13] = battery_voltage_centiV & 0x00FF ;
        send_packet_over_ble_steps = send_packet_over_ble_gather_data_step2 ;
        break;
    case send_packet_over_ble_gather_data_step2 :
        ble_response_array[14] = (wt_centilb >> 8) & 0x00FF ;
        ble_response_array[15] = wt_centilb & 0x00FF ;
        ble_response_array[16] = (Set_wt_centilb_other_motor >> 8) & 0x00FF ;
        ble_response_array[17] = Set_wt_centilb_other_motor & 0x00FF ;
#ifdef FakePodium_Rivu
        ble_response_array[16] = (wt_centilb >> 8) & 0x00FF ;
        ble_response_array[17] = wt_centilb & 0x00FF ;
#endif
        ble_response_array[18] = (start_force_position_decimm_used >> 8) & 0x00FF ;
        ble_response_array[19] = start_force_position_decimm_used & 0x00FF ;
        ble_response_array[20] = (start_force_position_other_motor_decimm >> 8) & 0x00FF ;
        ble_response_array[21] = start_force_position_other_motor_decimm & 0x00FF ;
#ifdef FakePodium_Rivu
        ble_response_array[20] = (start_force_position_decimm_used >> 8) & 0x00FF ;
        ble_response_array[21] = start_force_position_decimm_used & 0x00FF ;
#endif
        ble_response_array[22] = (advanced_wt_centilb >> 8) & 0x00FF ;
        ble_response_array[23] = advanced_wt_centilb & 0x00FF ;
        ble_response_array[24] = (Set_advanced_wt_centilb_other_motor >> 8) & 0x00FF ;
        ble_response_array[25] = Set_advanced_wt_centilb_other_motor & 0x00FF ;
#ifdef FakePodium_Rivu
        ble_response_array[24] = (advanced_wt_centilb >> 8) & 0x00FF ;
        ble_response_array[25] = advanced_wt_centilb & 0x00FF ;
#endif
        if((advanced_mode == advanced_mode_other_motor) && (advanced_mode_gain == advanced_mode_gain_other_motor))
            ble_response_array[26] = advanced_mode_status_flags & 0x00FF;
        else
            ble_response_array[26] = 0;
#ifdef FakePodium_Rivu
        ble_response_array[26] = advanced_mode_status_flags & 0x00FF;
#endif
        ble_response_array[27] = ((ble_packet_sent_counter >> 16) & 0x000000FF );
        ble_response_array[28] = ((ble_packet_sent_counter >> 8) & 0x000000FF );
        ble_response_array[29] = (ble_packet_sent_counter & 0x000000FF);
        send_packet_over_ble_steps = send_packet_over_ble_gather_data_step3;
        break;
    case send_packet_over_ble_gather_data_step3 :
        switch (loadcell_left_type)
        {
        case 0 :
            loadcell_left_lbx10 = loadcell_front_tared_lbx10_14bit;
            loadcell_left_type = 1;
            break;
        case 1 :
            loadcell_left_lbx10 = loadcell_front_1_tared_lbx10_14bit + 0b0100000000000000;
            loadcell_left_type = 2;
            break;
        case 2 :
            loadcell_left_lbx10 = loadcell_rear_tared_lbx10_14bit + 0b1000000000000000;
            loadcell_left_type = 3;
            break;
        case 3 :
            loadcell_left_lbx10 = loadcell_rear_1_tared_lbx10_14bit + 0b1100000000000000;
            loadcell_left_type = 0;
            break;
        default :
            break;
        }
        ble_response_array[30] = (loadcell_left_lbx10 >> 8) & 0x00FF ;
        ble_response_array[31] = loadcell_left_lbx10 & 0x00FF;
        ble_response_array[32] = status_smart_platform_left_and_right & 0x00FF;
        switch (loadcell_right_type)
        {
        case 0 :
            loadcell_right_lbx10 = loadcell_front_tared_lbx10_14bit_other_motor;
            loadcell_right_type = 1;
            break;
        case 1 :
            loadcell_right_lbx10 = loadcell_front_1_tared_lbx10_14bit_other_motor + 0b0100000000000000;
            loadcell_right_type = 2;
            break;
        case 2 :
            loadcell_right_lbx10 = loadcell_rear_tared_lbx10_14bit_other_motor + 0b1000000000000000;
            loadcell_right_type = 3;
            break;
        case 3 :
            loadcell_right_lbx10 = loadcell_rear_1_tared_lbx10_14bit_other_motor + 0b1100000000000000;
            loadcell_right_type = 0;
            break;
        default :
            break;
        }
        ble_response_array[33] = (loadcell_right_lbx10 >> 8) & 0x00FF;
        ble_response_array[34] = loadcell_right_lbx10 & 0x00FF;
        ble_response_array[35] = (velocity_mm_per_sec >> 8) & 0x00FF;
        ble_response_array[36] = velocity_mm_per_sec & 0x00FF;
        ble_response_array[37] = (velocity_other_motor_mm_per_sec >> 8) & 0x00FF;
        ble_response_array[38] = velocity_other_motor_mm_per_sec & 0x00FF;
        ble_response_array[39] = (accel_mm_per_sec_sq >> 8) & 0x00FF;
        ble_response_array[40] = accel_mm_per_sec_sq & 0x00FF;
        ble_response_array[41] = (accel_other_motor_mm_per_sec_sq >> 8) & 0x00FF;
        ble_response_array[42] = accel_other_motor_mm_per_sec_sq & 0x00FF;
        ble_response_array[43] = (Rmin_decimm >> 8) & 0x00FF;
        ble_response_array[44] = Rmin_decimm & 0x00FF;
        send_packet_over_ble_steps = send_packet_over_ble_gather_data_step4 ;
        break;
    case send_packet_over_ble_gather_data_step4 :
        ble_response_array[45] = (Rmin_other_motor_decimm >> 8) & 0x00FF;
        ble_response_array[46] = Rmin_other_motor_decimm & 0x00FF;
        ble_response_array[47] = (Rmax_decimm >> 8) & 0x00FF;
        ble_response_array[48] = Rmax_decimm & 0x00FF;
        ble_response_array[49] = (Rmax_other_motor_decimm >> 8) & 0x00FF;
        ble_response_array[50] = Rmax_other_motor_decimm & 0x00FF;
        ble_response_array[51] = Tballs & 0x00FF;
        ble_response_array[52] = Tballs_other_motor & 0x00FF;
        ble_response_array[53] = Bballs & 0x00FF;
        ble_response_array[54] = Bballs_other_motor & 0x00FF;
        ble_response_array[55] = (battery_current_centiA >> 8) & 0x00FF;
        ble_response_array[56] = battery_current_centiA & 0x00FF;
        muscle_strain = 900000;
        ble_response_array[57] = (muscle_strain >> 16) & 0x000000FF ;
        ble_response_array[58] = (muscle_strain >> 8) & 0x000000FF ;
        ble_response_array[59] = muscle_strain & 0x000000FF;
        send_packet_over_ble_steps = send_packet_over_ble_gather_crc16_step ;
        break;
    case send_packet_over_ble_gather_crc16_step :
        crc16_send_packet = getCRC16(ble_response_array[ble_response_array_counter],crc16_send_packet);
        if(ble_response_array_counter == 59)
            send_packet_over_ble_steps = send_packet_over_ble_point_to_1st_central_step;
        else
            ble_response_array_counter++;
        break;
    case send_packet_over_ble_point_to_1st_central_step :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty) 
        {
            ble_response_array[60] = (crc16_send_packet >> 8) & 0x00FF ;
            ble_response_array[61] = crc16_send_packet & 0x00FF ;
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step1;
        }
        break;
    case send_packet_over_ble_send_4bytes_step1 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[0]);
            HAL_writeSCIAFIFO(handle,ble_response_array[1]);
            HAL_writeSCIAFIFO(handle,ble_response_array[2]);
            HAL_writeSCIAFIFO(handle,ble_response_array[3]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step2;
        }
        break;
    case send_packet_over_ble_send_4bytes_step2 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[4]);
            HAL_writeSCIAFIFO(handle,ble_response_array[5]);
            HAL_writeSCIAFIFO(handle,ble_response_array[6]);
            HAL_writeSCIAFIFO(handle,ble_response_array[7]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step3;
        }
        break;
    case send_packet_over_ble_send_4bytes_step3 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[8]);
            HAL_writeSCIAFIFO(handle,ble_response_array[9]);
            HAL_writeSCIAFIFO(handle,ble_response_array[10]);
            HAL_writeSCIAFIFO(handle,ble_response_array[11]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step4;
        }
        break;
    case send_packet_over_ble_send_4bytes_step4 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[12]);
            HAL_writeSCIAFIFO(handle,ble_response_array[13]);
            HAL_writeSCIAFIFO(handle,ble_response_array[14]);
            HAL_writeSCIAFIFO(handle,ble_response_array[15]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step5;
        }
        break;
    case send_packet_over_ble_send_4bytes_step5 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[16]);
            HAL_writeSCIAFIFO(handle,ble_response_array[17]);
            HAL_writeSCIAFIFO(handle,ble_response_array[18]);
            HAL_writeSCIAFIFO(handle,ble_response_array[19]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step6;
        }
        break;
    case send_packet_over_ble_send_4bytes_step6 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[20]);
            HAL_writeSCIAFIFO(handle,ble_response_array[21]);
            HAL_writeSCIAFIFO(handle,ble_response_array[22]);
            HAL_writeSCIAFIFO(handle,ble_response_array[23]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step7;
        }
        break;
    case send_packet_over_ble_send_4bytes_step7 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[24]);
            HAL_writeSCIAFIFO(handle,ble_response_array[25]);
            HAL_writeSCIAFIFO(handle,ble_response_array[26]);
            HAL_writeSCIAFIFO(handle,ble_response_array[27]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step8;
        }
        break;
    case send_packet_over_ble_send_4bytes_step8 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[28]);
            HAL_writeSCIAFIFO(handle,ble_response_array[29]);
            HAL_writeSCIAFIFO(handle,ble_response_array[30]);
            HAL_writeSCIAFIFO(handle,ble_response_array[31]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step9;
        }
        break;
    case send_packet_over_ble_send_4bytes_step9 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[32]);
            HAL_writeSCIAFIFO(handle,ble_response_array[33]);
            HAL_writeSCIAFIFO(handle,ble_response_array[34]);
            HAL_writeSCIAFIFO(handle,ble_response_array[35]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step10;
        }
        break;
    case send_packet_over_ble_send_4bytes_step10 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[36]);
            HAL_writeSCIAFIFO(handle,ble_response_array[37]);
            HAL_writeSCIAFIFO(handle,ble_response_array[38]);
            HAL_writeSCIAFIFO(handle,ble_response_array[39]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step11;
        }
        break;
    case send_packet_over_ble_send_4bytes_step11 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[40]);
            HAL_writeSCIAFIFO(handle,ble_response_array[41]);
            HAL_writeSCIAFIFO(handle,ble_response_array[42]);
            HAL_writeSCIAFIFO(handle,ble_response_array[43]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step12;
        }
        break;
    case send_packet_over_ble_send_4bytes_step12 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[44]);
            HAL_writeSCIAFIFO(handle,ble_response_array[45]);
            HAL_writeSCIAFIFO(handle,ble_response_array[46]);
            HAL_writeSCIAFIFO(handle,ble_response_array[47]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step13;
        }
        break;
    case send_packet_over_ble_send_4bytes_step13 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[48]);
            HAL_writeSCIAFIFO(handle,ble_response_array[49]);
            HAL_writeSCIAFIFO(handle,ble_response_array[50]);
            HAL_writeSCIAFIFO(handle,ble_response_array[51]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step14;
        }
        break;
    case send_packet_over_ble_send_4bytes_step14 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[52]);
            HAL_writeSCIAFIFO(handle,ble_response_array[53]);
            HAL_writeSCIAFIFO(handle,ble_response_array[54]);
            HAL_writeSCIAFIFO(handle,ble_response_array[55]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step15;
        }
        break;
    case send_packet_over_ble_send_4bytes_step15 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[56]);
            HAL_writeSCIAFIFO(handle,ble_response_array[57]);
            HAL_writeSCIAFIFO(handle,ble_response_array[58]);
            HAL_writeSCIAFIFO(handle,ble_response_array[59]);
            send_packet_over_ble_steps = send_packet_over_ble_send_4bytes_step16;
        }
        break;
    case send_packet_over_ble_send_4bytes_step16 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            HAL_writeSCIAFIFO(handle,ble_response_array[60]);
            HAL_writeSCIAFIFO(handle,ble_response_array[61]);
            send_packet_over_ble_steps = send_packet_over_ble_bypass_step1;
        }
        break;
    case send_packet_over_ble_bypass_step1 :
        if(HAL_getTxFifoStatusSCIA(handle) == SCI_FifoStatus_Empty)
        {
            ble_packet_sent_counter++;
            send_packet_over_ble_steps = send_packet_over_ble_bypass_step2;
        }
        break;
    case send_packet_over_ble_bypass_step2 :
        break;
    default :
        break;
    }
    if(counter_send_ble_packet == counter_send_ble_packet_max) // 300 for 10khz = 33.33hz (30ms), 250 for 10khz = 40hz (25ms)
    {
        counter_send_ble_packet = 0;
        send_packet_over_ble_steps = send_packet_over_ble_gather_data_step0;
    }
    else
    {
        counter_send_ble_packet++;
    }
    return;
}// end of send_packet_over_ble() function

void read_packet_over_ble(HAL_Handle handle)
{
    test_counter1++;
    RxFifoStatusSCIA = HAL_getRxFifoStatusSCIA(handle);
    switch (RxFifoStatusSCIA)
    {
        case SCI_FifoStatus_4_Words : // if 4 words are in buffer from past, read and discard them
            test_counter2++;
            HAL_readSCIAFIFO(handle);
            HAL_readSCIAFIFO(handle);
            HAL_readSCIAFIFO(handle);
            HAL_readSCIAFIFO(handle);
            break;
        case SCI_FifoStatus_3_Words :// if 3 words are in buffer from past, read and discard them
            test_counter3++;
            HAL_readSCIAFIFO(handle);
            HAL_readSCIAFIFO(handle);
            HAL_readSCIAFIFO(handle);
            break;
        case SCI_FifoStatus_2_Words : // if 2 words are in buffer from past, read and discard them
            test_counter4++;
            HAL_readSCIAFIFO(handle);
            HAL_readSCIAFIFO(handle);
            break;
        case SCI_FifoStatus_1_Word :
            ble_recieve_packet_array[15] =  (HAL_readSCIAFIFO(handle) & 0x00FF);
            if(((ble_recieve_packet_array[0] << 8) + ble_recieve_packet_array[1]) == BLE_set_all_variables_in_one_packet_header)
            {
                crc16_recieve_packet = getCRC16(ble_recieve_packet_array[0],0xFFFF);
                read_packet_over_ble_steps = read_packet_over_ble_step1;
                ble_recieve_packet_array_counter = 0;
            }
            else
            {
            read_packet_over_ble_steps = read_packet_over_ble_step0;
            }
            ble_recieve_packet_array[0] = ble_recieve_packet_array[1];
            ble_recieve_packet_array[1] = ble_recieve_packet_array[2];
            ble_recieve_packet_array[2] = ble_recieve_packet_array[3];
            ble_recieve_packet_array[3] = ble_recieve_packet_array[4];
            ble_recieve_packet_array[4] = ble_recieve_packet_array[5];
            ble_recieve_packet_array[5] = ble_recieve_packet_array[6];
            ble_recieve_packet_array[6] = ble_recieve_packet_array[7];
            ble_recieve_packet_array[7] = ble_recieve_packet_array[8];
            ble_recieve_packet_array[8] = ble_recieve_packet_array[9];
            ble_recieve_packet_array[9] = ble_recieve_packet_array[10];
            ble_recieve_packet_array[10] = ble_recieve_packet_array[11];
            ble_recieve_packet_array[11] = ble_recieve_packet_array[12];
            ble_recieve_packet_array[12] = ble_recieve_packet_array[13];
            ble_recieve_packet_array[13] = ble_recieve_packet_array[14];
            ble_recieve_packet_array[14] = ble_recieve_packet_array[15];
            break;
        case SCI_FifoStatus_Empty :
            switch(read_packet_over_ble_steps)
            {
            case read_packet_over_ble_step1 :
                crc16_recieve_packet = getCRC16(ble_recieve_packet_array[ble_recieve_packet_array_counter],crc16_recieve_packet);
                if(ble_recieve_packet_array_counter == 11)
                {
                    read_packet_over_ble_steps = read_packet_over_ble_step2;
                }
                ble_recieve_packet_array_counter++;
                break;
            case read_packet_over_ble_step2 :
                crc16_recieve_packet = getCRC16(ble_recieve_packet_array[12],crc16_recieve_packet);
                if(crc16_recieve_packet == ((ble_recieve_packet_array[13] << 8 ) + ble_recieve_packet_array[14]))
                {
                    nominal_force_setting_input_over_ble_centiLbs = (ble_recieve_packet_array[1] << 8 ) + ble_recieve_packet_array[2];
                    advanced_force_setting_input_over_ble_centiLbs = (ble_recieve_packet_array[3] << 8 ) + ble_recieve_packet_array[4];
                    start_force_position_decimm = (ble_recieve_packet_array[5] << 8 ) + ble_recieve_packet_array[6];
                    status_flags_input_over_ble = ble_recieve_packet_array[7] & 0x00FF;
                    advanced_mode_status_flags_input_over_ble = ble_recieve_packet_array[8] & 0x00FF;
                    ble_packet_recieved++;
                    ms_since_last_ble_packet_from_App = 0;
                }
                read_packet_over_ble_steps = read_packet_over_ble_step0;
                break;
            case read_packet_over_ble_step0 :
                break;
            default :
                break;
            }
            break;
        default :
            break;
    }
    return;
}// end of read_packet_over_ble() function

void range_of_motion_and_rep_counter(void)
{
    switch(range_of_motion_states)
    {
        case ROM_Bottom_1 : // 213
            if(set_started)
            {
                if(ball_position > start_force_position)
                    range_of_motion_states = ROM_Concentric_1A;
            }
            Rmax = start_force_position;
            Rmin = start_force_position;
            Tballs = 0;
            Bballs = 0;
            At_top = true;
            At_bottom = true;
            Reps = 0;
            break;
        case ROM_Concentric_1A : // 214
            if(ball_position <= start_force_position)
               range_of_motion_states = ROM_Bottom_1;
            else
            {
                if(ball_position > (start_force_position + range_of_motion_commitment_constantx2)) // 21504)
                    range_of_motion_states = ROM_Concentric_1B;
            }
            Rmax = ball_position;
            Rmin = ball_position;
            break;
        case ROM_Concentric_1B : // 215
            if(ball_position < Rmax)
                range_of_motion_states = ROM_Eccentric_1A;
            else
                Rmax = ball_position;
            Rmin = ball_position;
            break;
        case ROM_Eccentric_1A : // 216
            if(ball_position >= Rmax)
                range_of_motion_states = ROM_Concentric_1B;
            if(ball_position < (Rmax - range_of_motion_commitment_constant))
                range_of_motion_states = ROM_Eccentric_1B;
            Rmin = ball_position;
            break;
        case ROM_Eccentric_1B : // 217
            Tballs = 1;
            At_top = false;
            if(ball_position > Rmin)
                range_of_motion_states = ROM_Concentric_2A;
            else
                Rmin = ball_position;
            if(ball_position <= start_force_position)
            {
                range_of_motion_states = ROM_Bottom;
                Rmin = start_force_position;
            }
            break;
        case ROM_Concentric_2A : // 218
            if(ball_position <= Rmin)
            {
                range_of_motion_states = ROM_Eccentric_1B;
                Rmin = ball_position;
            }
            else
            {
                if(ball_position > (Rmin + range_of_motion_commitment_constant))
                    range_of_motion_states = ROM_Concentric;
            }
            break;
        case ROM_Concentric : // 219
            if(Bballs == 0)
            {
                Bballs = 1;
                Reps = 1;
            }
            At_bottom = false;
            if(ball_position <= (Rmin + rep_forgiveness_band_ticks_at_bottom))
                range_of_motion_states = ROM_Bottom;
            if(ball_position >= (Rmax - rep_forgiveness_band_ticks_at_top))
                range_of_motion_states = ROM_Top;
            break;
        case ROM_Top : // 220
            if((!At_top) && (Tballs = Bballs))
            {
                At_top = true;
                Tballs++;
            }
            if(ball_position < Rmax)
                range_of_motion_states = ROM_Eccentric;
            break;
        case ROM_Eccentric : // 221
            At_top = false;
            if(ball_position >= (Rmax - rep_forgiveness_band_ticks_at_top))
                range_of_motion_states = ROM_Top;
            if(ball_position <= (Rmin + rep_forgiveness_band_ticks_at_bottom))
                range_of_motion_states = ROM_Bottom;
            break;
        case ROM_Bottom : // 222
            if((!At_bottom) && (Bballs < Tballs))
            {
                At_bottom = true;
                Bballs++;
                Reps++;
            }
            if(ball_position > (Rmin + rep_forgiveness_band_ticks_at_bottom))
                range_of_motion_states = ROM_Concentric;
            break;
        default:
            break;
    }
    return ;
} // end of range_of_motion_and_rep_counter() function

void update_outside_ISR(CTRL_Handle handle)
{
  CTRL_Obj *obj = (CTRL_Obj *)handle;
  float loadcell_delta_front_rear_tared_lb = 0.0f;
  float loadcell_delta_front_rear_1_tared_lb = 0.0f;
  float loadcell_front_plus_rear_tared_lb = 0.0f;
  float loadcell_front_plus_rear_1_tared_lb = 0.0f;
  //HAL_setGpioHigh(halHandle,GPIO_Number_10);

//  loadcell_front_tared_lb = ((float)loadcell_front_tared - 1005.4)*0.0648;
//  loadcell_front_1_tared_lb = ((float)loadcell_front_1_tared - 1042.5)*0.0688;
//  loadcell_rear_tared_lb = ((float)loadcell_rear_tared - 939.86)*0.06;
//  loadcell_rear_1_tared_lb = ((float)loadcell_rear_1_tared - 1002.6)*0.0686;

  loadcell_front_tared_lb = (((float)loadcell_front_tared_ma_sum) - loadcell_diff_window)*0.00065;
  if(!test_load_cell)
      loadcell_front_tared_lbx10_14bit = (uint16_t)(loadcell_front_tared_lb * 10.0);
  loadcell_front_1_tared_lb = (((float)loadcell_front_1_tared_ma_sum) - loadcell_diff_window)*0.00065;
  if(!test_load_cell)
      loadcell_front_1_tared_lbx10_14bit = (uint16_t)(loadcell_front_1_tared_lb * 10.0);
  loadcell_rear_tared_lb = (((float)loadcell_rear_tared_ma_sum) - loadcell_diff_window)*0.00065;
  if(!test_load_cell)
      loadcell_rear_tared_lbx10_14bit = (uint16_t)(loadcell_rear_tared_lb * 10.0);
  loadcell_rear_1_tared_lb = (((float)loadcell_rear_1_tared_ma_sum) - loadcell_diff_window)*0.00065;
  if(!test_load_cell)
      loadcell_rear_1_tared_lbx10_14bit = (uint16_t)(loadcell_rear_1_tared_lb * 10.0);

  loadcell_delta_front_rear_tared_lb = loadcell_front_tared_lb - loadcell_rear_tared_lb;
  loadcell_delta_front_rear_1_tared_lb = loadcell_front_1_tared_lb - loadcell_rear_1_tared_lb;
  loadcell_front_plus_rear_tared_lb = loadcell_front_tared_lb + loadcell_rear_tared_lb;
  loadcell_front_plus_rear_1_tared_lb = loadcell_front_1_tared_lb + loadcell_rear_1_tared_lb;
  loadcell_all_plus_tared_lb = loadcell_front_plus_rear_tared_lb + loadcell_front_plus_rear_1_tared_lb;
  loadcell_delta_front_rear_fraction = ((float) loadcell_delta_front_rear_tared_lb) / loadcell_front_plus_rear_tared_lb;
  loadcell_delta_front_rear_1_fraction = ((float) loadcell_delta_front_rear_1_tared_lb) / loadcell_front_plus_rear_1_tared_lb;

  if(loadcell_all_plus_tared_lb < non_zero_load_on_front_and_rear_loadcell_lb)
  {
      user_not_standing_on_platform = true;
      front_heavier_than_rear = false;
      rear_heavier_than_front = false;
      front_almost_same_heavy_as_rear = false;
      status_smart_platform = 0;
  }
  else
  {
      user_not_standing_on_platform = false;
      if((loadcell_delta_front_rear_fraction > min_balance_fraction) || (loadcell_delta_front_rear_1_fraction > min_balance_fraction))
      {
          front_heavier_than_rear = true;
          rear_heavier_than_front = false;
          front_almost_same_heavy_as_rear = false;
          status_smart_platform = 1;
      }
      else if((loadcell_delta_front_rear_fraction < -min_balance_fraction) || (loadcell_delta_front_rear_1_fraction < -min_balance_fraction))
      {
          front_heavier_than_rear = false;
          rear_heavier_than_front = true;
          front_almost_same_heavy_as_rear = false;
          status_smart_platform = 2;
      }
      else
      {
          front_heavier_than_rear = false;
          rear_heavier_than_front = false;
          front_almost_same_heavy_as_rear = true;
          status_smart_platform = 3;
      }
  }

  if((status_smart_platform == 3) && (status_smart_platform_other_motor == 3))
      platform_force_balanced = true;
  else
      platform_force_balanced = false;

//  if(status_smart_platform == 3)
//      platform_force_balanced = true;
//  else
//      platform_force_balanced = false;

  if(!test_load_cell)
  {
      status_smart_platform_left_and_right = ((status_smart_platform << 4) & 0b0000000000110000) + (status_smart_platform_other_motor & 0b0000000000000011);
  }
  else
  {
      status_smart_platform_left_and_right = ((status_smart_platform_left_test << 4) & 0b0000000000110000) + (status_smart_platform_right_test & 0b0000000000000011);
  }

  if(nominal_force_setting_input_over_ble_centiLbs < wt_centilb_default)
      wt_centilb = wt_centilb_default;
  else if(nominal_force_setting_input_over_ble_centiLbs > wt_centilb_max_limit)
      wt_centilb = wt_centilb_max_limit;
  else
      wt_centilb = nominal_force_setting_input_over_ble_centiLbs;

  if(advanced_force_setting_input_over_ble_centiLbs < wt_centilb_default)
      advanced_wt_centilb = wt_centilb_default;
  else if(advanced_force_setting_input_over_ble_centiLbs > wt_centilb_max_limit)
      advanced_wt_centilb = wt_centilb_max_limit;
  else
      advanced_wt_centilb = advanced_force_setting_input_over_ble_centiLbs;

  if(start_force_position_decimm < platform_to_roller_decimm)
      start_force_position_decimm_used = platform_to_roller_decimm;
  else if(start_force_position_decimm > start_force_position_decimm_max)
      start_force_position_decimm_used = start_force_position_decimm_max; // 8 feet
  else
      start_force_position_decimm_used = start_force_position_decimm;

  if(!serial_central_host_connected)
  {
      if(!ble_central_host_connected)
      {
          wt_centilb = wt_centilb_default;
          advanced_wt_centilb = wt_centilb_default;
          start_force_position_decimm_used = platform_to_roller_decimm;
          set_started = false;
          status_flags_input_over_ble = 0;
          advanced_mode_status_flags_input_over_ble = 0;
          status_smart_platform = 0;
      }
  }

  if(reset_if_no_consistent_downstream_packets)
  {
      if(ms_since_last_ble_packet_from_App > 1000) // 1000ms = 1 sec
      {
          wt_centilb = wt_centilb_default;
          advanced_wt_centilb = wt_centilb_default;
          start_force_position_decimm_used = platform_to_roller_decimm;
          set_started = false;
          status_flags_input_over_ble = 0;
          advanced_mode_status_flags_input_over_ble = 0;
          status_smart_platform = 0;
      }
  }

  if(!force_enabled)
  {
      wt_centilb = wt_centilb_default;
      advanced_wt_centilb = wt_centilb_default;
      start_force_position_decimm_used = platform_to_roller_decimm;
      set_started = false;
      status_flags_input_over_ble = 0;
      advanced_mode_status_flags_input_over_ble = 0;
      status_smart_platform = 0;
  }

  smart_barbell_enabled = (bool)(status_flags_input_over_ble & 0b0000000000000001);
  bar_stabilization_factor_enable = (bool)((status_flags_input_over_ble & 0b0000000000000100) >> 2);
  smart_platform_enabled = (bool)((status_flags_input_over_ble & 0b0000000000001000) >> 3);
  advanced_mode_flag = (bool)((status_flags_input_over_ble & 0b0000000000010000) >> 4);
  dynamic_iso_perturbation_flag = (bool)((status_flags_input_over_ble & 0b0000000000100000) >> 5);
  bar_attachment_connected = (bool)((status_flags_input_over_ble & 0b0000000001000000) >> 6);
  solenoid_lock_flag_input = (bool)((status_flags_input_over_ble & 0b0000000010000000) >> 7);
  advanced_mode_status_flags = advanced_mode_status_flags_input_over_ble & 0b0000000001111111;
  advanced_mode = (advanced_mode_status_flags & 0b0000000001110000) >> 4;
  advanced_mode_gain = advanced_mode_status_flags & 0b0000000000000011;
  Status_other_motor = Status_flags_other_motor & 0x00FF;
  advanced_mode_status_flags_other_motor = (Status_flags_other_motor >> 8);
  if(force_enabled_other_motor)
     advanced_mode_status_flags_sent_to_other_motor = (1 << 7) +  (advanced_mode << 4) + (status_smart_platform << 2) + advanced_mode_gain;
    else
     advanced_mode_status_flags_sent_to_other_motor = (advanced_mode << 4) + (status_smart_platform << 2) + advanced_mode_gain;

  advanced_mode_other_motor = (advanced_mode_status_flags_other_motor & 0b0000000001110000) >> 4;
  advanced_mode_gain_other_motor = advanced_mode_status_flags_other_motor & 0b0000000000000011;
  status_smart_platform_other_motor = (advanced_mode_status_flags_other_motor & 0b0000000000001100) >> 2;

  if(!manually_set_weight)
  {
      wt_lb = wt_centilb * 0.01; // need to convert to IQ math
      advanced_wt_lb = advanced_wt_centilb * 0.01; // need to convert to IQ math
      bar_stabilization_factor_enable_manual = bar_stabilization_factor_enable;
  }

  wt_lb_desired = wt_lb;

  start_force_position = USER_MOTOR_START_COUNT + ((start_force_position_decimm_used - platform_to_roller_decimm) * decimm_to_ticks_conversion);
  Rmax_decimm = (uint16_t)(((Rmax - USER_MOTOR_START_COUNT) * ticks_to_decimm_conversion) + platform_to_roller_decimm);
  Rmin_decimm = (uint16_t)(((Rmin - USER_MOTOR_START_COUNT) * ticks_to_decimm_conversion) + platform_to_roller_decimm);
  Rmax_other_motor = USER_MOTOR_START_COUNT + ((Rmax_other_motor_decimm - platform_to_roller_decimm) * decimm_to_ticks_conversion);
  Rmin_other_motor = USER_MOTOR_START_COUNT + ((Rmin_other_motor_decimm - platform_to_roller_decimm) * decimm_to_ticks_conversion);
  accel_mm_per_sec_sq = -10;
  velocity_mm_per_sec = -20;

  if(!setup_done)
  {
      // get encoder count max
      gMotorVars.EncCountMax =  HAL_getQepPosnMaximum(halHandle,HAL_Qep_QEP1);

      // get the real time speed reference coming out of the speed trajectory generator
      gMotorVars.SpeedTraj_krpm = _IQmpy(CTRL_getSpd_int_ref_pu(handle),EST_get_pu_to_krpm_sf(obj->estHandle));

      // get the torque estimate
      gMotorVars.Torque_Nm = USER_computeTorque_Nm(handle, gTorque_Flux_Iq_pu_to_Nm_sf, gTorque_Ls_Id_Iq_pu_to_Nm_sf);

      // get the stator resistance
      gMotorVars.Rs_Ohm = EST_getRs_Ohm(obj->estHandle);

      // get the stator resistance online
      gMotorVars.RsOnLine_Ohm = EST_getRsOnLine_Ohm(obj->estHandle);

      // get the stator inductance in the direct coordinate direction
      gMotorVars.Lsd_H = EST_getLs_d_H(obj->estHandle);

      // get the stator inductance in the quadrature coordinate direction
      gMotorVars.Lsq_H = EST_getLs_q_H(obj->estHandle);
  }

  // get the flux in V/Hz in floating point
  gMotorVars.Flux_VpHz = EST_getFlux_VpHz(obj->estHandle);

  // get the magnetizing current
  gMotorVars.MagnCurr_A = EST_getIdRated(obj->estHandle);

  // get the flux in Wb in fixed point
  gMotorVars.Flux_Wb = USER_computeFlux(handle, gFlux_pu_to_Wb_sf);

  // get the speed estimate
  gMotorVars.Speed_krpm = EST_getSpeed_krpm(obj->estHandle);

  // get the controller state
  gMotorVars.CtrlState = CTRL_getState(handle);

  // get the estimator state
  gMotorVars.EstState = EST_getState(obj->estHandle);

  // read Vd and Vq vectors per units
  gMotorVars.Vd = CTRL_getVd_out_pu(ctrlHandle);
  gMotorVars.Vq = CTRL_getVq_out_pu(ctrlHandle);

  // calculate vector Vs in per units
  gMotorVars.Vs = _IQsqrt(_IQmpy(gMotorVars.Vd, gMotorVars.Vd) + _IQmpy(gMotorVars.Vq, gMotorVars.Vq));

  // read Id and Iq vectors in amps
  gMotorVars.Id_A = _IQmpy(CTRL_getId_in_pu(ctrlHandle), _IQ(USER_IQ_FULL_SCALE_CURRENT_A));
  gMotorVars.Iq_A = _IQmpy(CTRL_getIq_in_pu(ctrlHandle), _IQ(USER_IQ_FULL_SCALE_CURRENT_A));

  wt_centilb_measured = (uint16_t)(wt_lb_actually_set_measured * 100.0); // comment convert this to IQmath

  // calculate vector Is in amps
  gMotorVars.Is_A = _IQsqrt(_IQmpy(gMotorVars.Id_A, gMotorVars.Id_A) + _IQmpy(gMotorVars.Iq_A, gMotorVars.Iq_A));

  // Get the DC buss voltage
  gMotorVars.VdcBus_kV = _IQmpy(gAdcData.dcBus,_IQ(USER_IQ_FULL_SCALE_VOLTAGE_kV));
  battery_voltage_centiV = (uint16_t)(_IQtoF(gMotorVars.VdcBus_kV) * 100000.0);
  duty_cycle_5v = 500.0/battery_voltage_centiV;
  duty_cycle_10v = duty_cycle_5v * 2.0;

//  battery_voltage_V = _IQtoF(gMotorVars.VdcBus_kV) * 1000.0;
//  dc_bus_current_inA = ((dc_bus_current_bits * 0.0303) - 63.0);
//  Battery_Power_W = battery_voltage_V * dc_bus_current_inA;
//  Thermistor_reading_bits  = HAL_readAnalogData(halHandle,ADC_ResultNumber_12); // value is 12-bit so varies from 0 to 4095
//  Thermistor_deg_C = (-0.000000004 * Thermistor_reading_bits * Thermistor_reading_bits * Thermistor_reading_bits) + (0.00003 * Thermistor_reading_bits * Thermistor_reading_bits) - (0.0972 * Thermistor_reading_bits) + 152.11;

  //HAL_setGpioLow(halHandle,GPIO_Number_10);
  return;
} // end of update_outside_ISR() function

void main(void)
{ // PB2
    uint_least8_t estNumber = 0;
  #ifdef FAST_ROM_V1p6
    uint_least8_t ctrlNumber = 0;
  #endif
    // Only used if running from FLASH , // Note that the variable FLASH is defined by the project
    #ifdef FLASH
    // Copy time critical code and Flash setup code to RAM // The RamfuncsLoadStart, RamfuncsLoadEnd, and RamfuncsRunStart
    // symbols are created by the linker. Refer to the linker files.
    memCopy((uint16_t *)&RamfuncsLoadStart,(uint16_t *)&RamfuncsLoadEnd,(uint16_t *)&RamfuncsRunStart);

  #ifdef CSM_ENABLE
    //copy .econst to unsecure RAM
    if(*econst_end - *econst_start)
      {
        memCopy((uint16_t *)&econst_start,(uint16_t *)&econst_end,(uint16_t *)&econst_ram_load);
      }

    //copy .switch ot unsecure RAM
    if(*switch_end - *switch_start)
      {
        memCopy((uint16_t *)&switch_start,(uint16_t *)&switch_end,(uint16_t *)&switch_ram_load);
      }
  #endif
  #endif

  // initialize the hardware abstraction layer
  halHandle = HAL_init(&hal,sizeof(hal));
  // check for errors in user parameters
  USER_checkForErrors(&gUserParams);
  // store user parameter error in global variable
  gMotorVars.UserErrorCode = USER_getErrorCode(&gUserParams);
  // do not allow code execution if there is a user parameter error
  if(gMotorVars.UserErrorCode != USER_ErrorCode_NoError)
    {
      for(;;)
        {
          gMotorVars.Flag_enableSys = false;
        }
    }

  // initialize the user parameters
  USER_setParams(&gUserParams);
  // set the hardware abstraction layer parameters
  HAL_setParams(halHandle,&gUserParams);
  HAL_setDacParameters(&gDacData,duty_cycle);
  HAL_writeDacData(halHandle,&gDacData);

#ifdef FakePodium
 //disable all pwms by making the pins output and LOW
  HAL_setGpioMode(halHandle,GPIO_Number_0,GPIO_0_Mode_GeneralPurpose);
  HAL_setGpioLow(halHandle,GPIO_Number_0);
  HAL_setGpioDirection(halHandle,GPIO_Number_0,GPIO_Direction_Output);
  HAL_setGpioMode(halHandle,GPIO_Number_1,GPIO_1_Mode_GeneralPurpose);
  HAL_setGpioLow(halHandle,GPIO_Number_1);
  HAL_setGpioDirection(halHandle,GPIO_Number_1,GPIO_Direction_Output);
  HAL_setGpioMode(halHandle,GPIO_Number_2,GPIO_2_Mode_GeneralPurpose);
  HAL_setGpioLow(halHandle,GPIO_Number_2);
  HAL_setGpioDirection(halHandle,GPIO_Number_2,GPIO_Direction_Output);
  HAL_setGpioMode(halHandle,GPIO_Number_3,GPIO_3_Mode_GeneralPurpose);
  HAL_setGpioLow(halHandle,GPIO_Number_3);
  HAL_setGpioDirection(halHandle,GPIO_Number_3,GPIO_Direction_Output);
  HAL_setGpioMode(halHandle,GPIO_Number_4,GPIO_4_Mode_GeneralPurpose);
  HAL_setGpioLow(halHandle,GPIO_Number_4);
  HAL_setGpioDirection(halHandle,GPIO_Number_4,GPIO_Direction_Output);
  HAL_setGpioMode(halHandle,GPIO_Number_5,GPIO_5_Mode_GeneralPurpose);
  HAL_setGpioLow(halHandle,GPIO_Number_5);
  HAL_setGpioDirection(halHandle,GPIO_Number_5,GPIO_Direction_Output);
  // disable trip zone inputs by making them GPI
  HAL_setGpioMode(halHandle,GPIO_Number_13,GPIO_13_Mode_GeneralPurpose);
  HAL_setGpioDirection(halHandle,GPIO_Number_13,GPIO_Direction_Input);
  HAL_setGpioMode(halHandle,GPIO_Number_14,GPIO_14_Mode_GeneralPurpose);
  HAL_setGpioDirection(halHandle,GPIO_Number_14,GPIO_Direction_Input);
#endif

#ifdef FakePodium_Rivu
 //disable all pwms by making the pins GPO and LOW
  HAL_setGpioMode(halHandle,GPIO_Number_0,GPIO_0_Mode_GeneralPurpose);
  HAL_setGpioLow(halHandle,GPIO_Number_0);
  HAL_setGpioDirection(halHandle,GPIO_Number_0,GPIO_Direction_Output);
  HAL_setGpioMode(halHandle,GPIO_Number_1,GPIO_1_Mode_GeneralPurpose);
  HAL_setGpioLow(halHandle,GPIO_Number_1);
  HAL_setGpioDirection(halHandle,GPIO_Number_1,GPIO_Direction_Output);
  HAL_setGpioMode(halHandle,GPIO_Number_2,GPIO_2_Mode_GeneralPurpose);
  HAL_setGpioLow(halHandle,GPIO_Number_2);
  HAL_setGpioDirection(halHandle,GPIO_Number_2,GPIO_Direction_Output);
  HAL_setGpioMode(halHandle,GPIO_Number_3,GPIO_3_Mode_GeneralPurpose);
  HAL_setGpioLow(halHandle,GPIO_Number_3);
  HAL_setGpioDirection(halHandle,GPIO_Number_3,GPIO_Direction_Output);
  HAL_setGpioMode(halHandle,GPIO_Number_4,GPIO_4_Mode_GeneralPurpose);
  HAL_setGpioLow(halHandle,GPIO_Number_4);
  HAL_setGpioDirection(halHandle,GPIO_Number_4,GPIO_Direction_Output);
  HAL_setGpioMode(halHandle,GPIO_Number_5,GPIO_5_Mode_GeneralPurpose);
  HAL_setGpioLow(halHandle,GPIO_Number_5);
  HAL_setGpioDirection(halHandle,GPIO_Number_5,GPIO_Direction_Output);
  // disable trip zone inputs by making them GPI
  HAL_setGpioMode(halHandle,GPIO_Number_13,GPIO_13_Mode_GeneralPurpose);
  HAL_setGpioDirection(halHandle,GPIO_Number_13,GPIO_Direction_Input);
  HAL_setGpioMode(halHandle,GPIO_Number_14,GPIO_14_Mode_GeneralPurpose);
  HAL_setGpioDirection(halHandle,GPIO_Number_14,GPIO_Direction_Input);
#endif

  // initialize the controller
#ifdef FAST_ROM_V1p6
  ctrlHandle = CTRL_initCtrl(ctrlNumber, estNumber);  		//v1p6 format (06xF and 06xM devices)
  controller_obj = (CTRL_Obj *)ctrlHandle;
#else
  ctrlHandle = CTRL_initCtrl(estNumber,&ctrl,sizeof(ctrl));	//v1p7 format default
#endif
  CTRL_Version version;
  // get the version number
  CTRL_getVersion(ctrlHandle,&version);
  gMotorVars.CtrlVersion = version;
  // set the default controller parameters
  CTRL_setParams(ctrlHandle,&gUserParams);
  // setup faults
  HAL_setupFaults(halHandle);
  // initialize the interrupt vector table
  HAL_initIntVectorTable(halHandle);
  // enable the ADC interrupts
  HAL_enableAdcInts(halHandle);
  // enable global interrupts
  HAL_enableGlobalInts(halHandle);
  // enable debug interrupts
  HAL_enableDebugInt(halHandle);
  // disable the PWM
  HAL_disablePwm(halHandle);
  // initialize the ENC module
  encHandle = ENC_init(&enc, sizeof(enc));
  encHandle_1 = ENC_init(&enc, sizeof(enc_1));
  // setup the ENC module
  ENC_setup(encHandle, 1, USER_MOTOR_NUM_POLE_PAIRS, USER_MOTOR_ENCODER_LINES, 0, USER_IQ_FULL_SCALE_FREQ_Hz, USER_ISR_FREQ_Hz, 8000.0);
  ENC_setup(encHandle_1, 1, USER_MOTOR_NUM_POLE_PAIRS, USER_MOTOR_ENCODER_LINES, 0, USER_IQ_FULL_SCALE_FREQ_Hz, USER_ISR_FREQ_Hz, 8000.0);
#ifdef DRV8301_SPI
  // turn on the DRV8301 if present
  HAL_enableDrv(halHandle);
  // initialize the DRV8301 interface
  HAL_setupDrvSpi(halHandle,&gDrvSpi8301Vars);
#endif
#ifdef DRV8305_SPI
  // turn on the DRV8305 if present
  HAL_enableDrv(halHandle);
  // initialize the DRV8305 interface
  HAL_setupDrvSpi(halHandle,&gDrvSpi8305Vars);
#endif
  // enable DC bus compensation
  CTRL_setFlag_enableDcBusComp(ctrlHandle, true);
  // initialize the CPU usage module
  cpu_timeHandle = CPU_TIME_init(&cpu_time,sizeof(cpu_time));
  CPU_TIME_setParams(cpu_timeHandle, (USER_SYSTEM_FREQ_KHz/USER_ISR_FREQ_kHz) - 100);
  // compute scaling factors for flux and torque calculations
  gFlux_pu_to_Wb_sf = USER_computeFlux_pu_to_Wb_sf();
  gFlux_pu_to_VpHz_sf = USER_computeFlux_pu_to_VpHz_sf();
  gTorque_Ls_Id_Iq_pu_to_Nm_sf = USER_computeTorque_Ls_Id_Iq_pu_to_Nm_sf();
  gTorque_Flux_Iq_pu_to_Nm_sf = USER_computeTorque_Flux_Iq_pu_to_Nm_sf();

  iq_var_min_limit = _IQmpy(_IQ(IqRef_A_min_limit),_IQ(RECIPROCAL_USER_IQ_FULL_SCALE_CURRENT_A));
  iq_var_max_limit = _IQmpy(_IQ(IqRef_A_max_limit),_IQ(RECIPROCAL_USER_IQ_FULL_SCALE_CURRENT_A));

  for(;;)
  {
    // Waiting for enable system flag to be set
    while(!(gMotorVars.Flag_enableSys));
    // Dis-able the Library internal PI.  Iq has no reference now
    CTRL_setFlag_enableSpeedCtrl(ctrlHandle, false);
    // loop while the enable system flag is true
    while(gMotorVars.Flag_enableSys)
      {
        CTRL_Obj *obj = (CTRL_Obj *)ctrlHandle;
        if(!setup_done)
        {
            if(run_sensored)
                gMotorVars.Flag_enableForceAngle = false;
            else
                gMotorVars.Flag_enableForceAngle = true;
            EST_setFlag_enableForceAngle(obj->estHandle,gMotorVars.Flag_enableForceAngle);
            // increment counters
            gCounter_updateGlobals++;
            // enable/disable the use of motor parameters being loaded from user.h
            CTRL_setFlag_enableUserMotorParams(ctrlHandle,gMotorVars.Flag_enableUserParams);
            gMotorVars.Flag_enableRsRecalc = ENCODER_PRESENT;
            // enable/disable Rs recalibration during motor startup
            EST_setFlag_enableRsRecalc(obj->estHandle,gMotorVars.Flag_enableRsRecalc);
            // enable/disable automatic calculation of bias values
            CTRL_setFlag_enableOffset(ctrlHandle,gMotorVars.Flag_enableOffsetcalc);
            if(CTRL_isError(ctrlHandle))
              {
                // set the enable controller flag to false
                CTRL_setFlag_enableCtrl(ctrlHandle,false);
                // set the enable system flag to false
                gMotorVars.Flag_enableSys = false;
                // disable the PWM
                HAL_disablePwm(halHandle);
              }
            else
              {
                // update the controller state
                bool flag_ctrlStateChanged = CTRL_updateState(ctrlHandle);
                // enable or disable the control
                CTRL_setFlag_enableCtrl(ctrlHandle, gMotorVars.Flag_Run_Identify);
                if(flag_ctrlStateChanged)
                  {
                    CTRL_State_e ctrlState = CTRL_getState(ctrlHandle);
                    if(ctrlState == CTRL_State_OffLine)
                      {
                        // enable the PWM
                        HAL_enablePwm(halHandle);
                      }
                    else if(ctrlState == CTRL_State_OnLine)
                      {
                        if(gMotorVars.Flag_enableOffsetcalc == true)
                        {
                          // update the ADC bias values
                          HAL_updateAdcBias(halHandle);
                        }
                        else
                        {
                          // set the current bias
                          HAL_setBias(halHandle,HAL_SensorType_Current,0,_IQ(I_A_offset));
                          HAL_setBias(halHandle,HAL_SensorType_Current,1,_IQ(I_B_offset));
                          HAL_setBias(halHandle,HAL_SensorType_Current,2,_IQ(I_C_offset));

                          // set the voltage bias
                          HAL_setBias(halHandle,HAL_SensorType_Voltage,0,_IQ(V_A_offset));
                          HAL_setBias(halHandle,HAL_SensorType_Voltage,1,_IQ(V_B_offset));
                          HAL_setBias(halHandle,HAL_SensorType_Voltage,2,_IQ(V_C_offset));
                        }
                        // Return the bias value for currents
                        gMotorVars.I_bias.value[0] = HAL_getBias(halHandle,HAL_SensorType_Current,0);
                        gMotorVars.I_bias.value[1] = HAL_getBias(halHandle,HAL_SensorType_Current,1);
                        gMotorVars.I_bias.value[2] = HAL_getBias(halHandle,HAL_SensorType_Current,2);
                        // Return the bias value for voltages
                        gMotorVars.V_bias.value[0] = HAL_getBias(halHandle,HAL_SensorType_Voltage,0);
                        gMotorVars.V_bias.value[1] = HAL_getBias(halHandle,HAL_SensorType_Voltage,1);
                        gMotorVars.V_bias.value[2] = HAL_getBias(halHandle,HAL_SensorType_Voltage,2);
                        // enable the PWM
                        HAL_enablePwm(halHandle);
                      }
                    else if(ctrlState == CTRL_State_Idle)
                      {
                        // disable the PWM
                        HAL_disablePwm(halHandle);
                        gMotorVars.Flag_Run_Identify = false;
                      }
                    if((CTRL_getFlag_enableUserMotorParams(ctrlHandle) == true) &&
                      (ctrlState > CTRL_State_Idle) &&
                      (gMotorVars.CtrlVersion.minor == 6))
                      {
                        // call this function to fix 1p6
                        USER_softwareUpdate1p6(ctrlHandle);
                      }
                  }
              }
            if(EST_isMotorIdentified(obj->estHandle))
              {
                // set the current ramp
                EST_setMaxCurrentSlope_pu(obj->estHandle,gMaxCurrentSlope);
                gMotorVars.Flag_MotorIdentified = true;
                if(Flag_Latch_softwareUpdate)
                {
                  Flag_Latch_softwareUpdate = false;
                  USER_calcPIgains(ctrlHandle);
                  // initialize the watch window kp and ki current values with pre-calculated values
                  //gMotorVars.Kp_Idq = CTRL_getKp(ctrlHandle,CTRL_Type_PID_Id);
                  gMotorVars.Kp_Idq = _IQ(Kp_IDQ_TUNED);
                  //gMotorVars.Ki_Idq = CTRL_getKi(ctrlHandle,CTRL_Type_PID_Id);
                  gMotorVars.Ki_Idq = _IQ(Ki_IDQ_TUNED);
                }
              }
            else
              {
                Flag_Latch_softwareUpdate = true;
                // the estimator sets the maximum current slope during identification
                gMaxCurrentSlope = EST_getMaxCurrentSlope_pu(obj->estHandle);
              }

            if(drv8301_spi_write_enable)
                HAL_writeDrvData(halHandle,&gDrvSpi8301Vars);
            if(drv8301_spi_read_enable)
                HAL_readDrvData(halHandle,&gDrvSpi8301Vars);

            if((gMotorVars.CtrlState == CTRL_State_OnLine) && (gMotorVars.Flag_MotorIdentified == true) && (Flag_Latch_softwareUpdate == false))
              {
                // set the kp and ki current values for Id and Iq from the watch window
                CTRL_setKp(ctrlHandle,CTRL_Type_PID_Id,gMotorVars.Kp_Idq);
                CTRL_setKi(ctrlHandle,CTRL_Type_PID_Id,gMotorVars.Ki_Idq);
                CTRL_setKp(ctrlHandle,CTRL_Type_PID_Iq,gMotorVars.Kp_Idq);
                CTRL_setKi(ctrlHandle,CTRL_Type_PID_Iq,gMotorVars.Ki_Idq);
              }
        }
		
        // ********** START user code goes here - non time critical code ***********
        if(state_gpo_44_relay_switch)
            HAL_setGpioHigh(halHandle,GPIO_Number_44);
        else
            HAL_setGpioLow(halHandle,GPIO_Number_44);

//        if(enable_solenoid_brake)
//        {
//            if(solenoid_lock_flag_input)
//                HAL_setGpioHigh(halHandle,GPIO_Number_10); // turn solenoid on, releases brake
//            else
//                HAL_setGpioLow(halHandle,GPIO_Number_10);// turn solenoid off, engages brake
//        }

        state_gpio50 = HAL_readGpio(halHandle,GPIO_Number_50);

        if(usb_serial_comms_allowed)
            usb_serial_disconnected = state_gpio50;
        else
            usb_serial_disconnected = true;

        state_gpio41 = HAL_readGpio(halHandle,GPIO_Number_41);
        state_gpio42 = HAL_readGpio(halHandle,GPIO_Number_42);

        update_outside_ISR(ctrlHandle);
        // ********** END user code - non time critical code ***********

      } // end of while(gFlag_enableSys) loop
    // disable the PWM
    HAL_disablePwm(halHandle);
    // set the default controller parameters (Reset the control to re-identify the motor)
    CTRL_setParams(ctrlHandle,&gUserParams);
    gMotorVars.Flag_Run_Identify = false;
  } // end of for(;;) loop
} // end of main() function

interrupt void mainISR(void) // gets called at 10khz ie 100us , it used to be 15khz ie every 66.6666667 us
{
  float dX_float;
  float diff_float = 0.0;
  float diff_float_1 = 0.0;
  CTRL_Obj *obj = (CTRL_Obj *)ctrlHandle;
  //HAL_setGpioHigh(halHandle,GPIO_Number_6);
  // timer 2 is used for CPU time diagnostics   // read the timer 2 value and update the CPU usage module
  timer2Cnt = HAL_readTimerCnt(halHandle,2);
  CPU_TIME_updateCnts(cpu_timeHandle,timer2Cnt);

  // acknowledge the ADC interrupt
  HAL_acqAdcInt(halHandle,ADC_IntNumber_1);
  // convert the ADC data
  HAL_readAdcData(halHandle,&gAdcData);
  // read adc for bus current from dc battery
  dc_bus_current_bits = HAL_readAnalogData(halHandle,ADC_ResultNumber_10); // value is 12-bit so varies from 0 to 4095


  // read encoder value
  gMotorVars.EncCount = HAL_getQepPosnCounts(halHandle,HAL_Qep_QEP1);
  EncCount_1 = HAL_getQepPosnCounts(halHandle,HAL_Qep_QEP2);

  if(read_encoder_spiA)
  {
      HAL_setGpioHigh(halHandle,GPIO_Number_19);
      if(HAL_getTxFifoStatusSPIA(halHandle) == )
      read_16bit_SPIA_temp = HAL_readSPIA(halHandle);
      if (read_16bit_SPIA_temp & 0b0100000000000000)
      {
          SPIA_read_framming_error_counter++;
      }
      else
      {
          Encoder_count_prev = Encoder_count;
          Encoder_count = (read_16bit_SPIA_temp & 0b0011111111111111) >> 2 ;
          Encoder_diff = Encoder_count - Encoder_count_prev;
          if(Encoder_diff > 2047)
              turns = turns - 1;
          else if(Encoder_diff < -2047)
              turns = turns + 1;
          Encoder_count_multiturn = (((uint32_t)(4096.0 * turns)) - 1) + Encoder_count;
      }
      HAL_setGpioLow(halHandle,GPIO_Number_19);
      HAL_writeSPIA(halHandle,0xFFFF);
      //HAL_writeSPIA(halHandle,0xFFFF);
  }

  // serial data exchange between two motor controllers
  if(enable_serial_exchange)
  {
      send_packet_over_serial(halHandle);
      check_for_packet_received_over_serial(halHandle);
  }

  if(force_enabled && (gMotorVars.CtrlState == CTRL_State_OnLine) && (gMotorVars.EstState == EST_State_OnLine))
  {
      if(serial_exchange_working_in_both_directions && (!setup_done))
      {
          HAL_setGpioHigh(halHandle,GPIO_Number_8); // releases the BLE module from hardware reset
          setup_done = true;
          read_encoder_spiA = true;
      }
  }

  if(setup_done)
  {
//      if(switching_between_ble_and_usb_serial_allowed)
//      {
//          if(!usb_serial_disconnected)
//          {
//              if(!usb_serial_connected_step1)
//              {
//                  HAL_setGpioLow(halHandle,GPIO_Number_8);// holds BLE in reset
//                  switch_ble_on_serial = true;
//                  ble_on_serial = false;
//                  enable_ble_recieve_data = true;
//                  enable_ble_send_data = true;
//                  start_intialize_ble = false;
//                  ble_intilization_done = false;
//                  start_intialize_ble_again = false;
//                  ble_central_host_connected = false;
//                  serial_central_host_connected = true;
//                  usb_serial_connected_step1 = true;
//                  usb_serial_flag = true;
//              }
//          }
//          else  // usb_serial_disconnected = true always for poc and fake podium
//          {
//              if(!start_intialize_ble_again)
//              {
//                  HAL_setGpioHigh(halHandle,GPIO_Number_8); // releases the BLE module from hardware reset
//                  start_intialize_ble = true;
//                  start_intialize_ble_again = true;
//                  switch_ble_on_serial = true;
//                  ble_on_serial = true;
//                  enable_ble_recieve_data = true;
//                  enable_ble_send_data = false;
//                  ble_broadcasting = true;
//                  usb_serial_connected_step1 = false;
//                  usb_serial_flag = false;
//                  serial_central_host_connected = false;
//                  ble_central_host_connected = false;
//              }
//          }
//      }

//      if(switch_ble_on_serial)
//      {
//          switch_ble_on_serial = false;
//          if(ble_on_serial) // ble on serial
//          {
//              HAL_setGpioMode(halHandle,GPIO_Number_7,GPIO_7_Mode_GeneralPurpose);
//              HAL_setGpioDirection(halHandle,GPIO_Number_7,GPIO_Direction_Input);
//              HAL_setGpioPullup(halHandle,GPIO_Number_7,GPIO_Pullup_Enable);
//              HAL_setGpioMode(halHandle,GPIO_Number_12,GPIO_12_Mode_GeneralPurpose);
//              HAL_setGpioLow(halHandle,GPIO_Number_12);
//              HAL_setGpioDirection(halHandle,GPIO_Number_12,GPIO_Direction_Output);
//              HAL_setGpioMode(halHandle,GPIO_Number_28,GPIO_28_Mode_SCIRXDA);
//              HAL_setGpioMode(halHandle,GPIO_Number_29,GPIO_29_Mode_SCITXDA);
//          }
//          else // ble not on serial, usb serial is on serial
//          {
//              HAL_setGpioMode(halHandle,GPIO_Number_7,GPIO_7_Mode_SCIRXDA);
//              HAL_setGpioMode(halHandle,GPIO_Number_12,GPIO_12_Mode_SCITXDA);
//              HAL_setGpioMode(halHandle,GPIO_Number_28,GPIO_28_Mode_GeneralPurpose);
//              HAL_setGpioDirection(halHandle,GPIO_Number_28,GPIO_Direction_Input);
//              HAL_setGpioPullup(halHandle,GPIO_Number_28, GPIO_Pullup_Enable);
//              HAL_setGpioMode(halHandle,GPIO_Number_29,GPIO_29_Mode_GeneralPurpose);
//              HAL_setGpioHigh(halHandle,GPIO_Number_29);
//              HAL_setGpioDirection(halHandle,GPIO_Number_29,GPIO_Direction_Output);
//          }
//      }

      if(ble_central_host_connected)
      {
          read_packet_over_ble(halHandle);
          send_packet_over_ble(halHandle);
          if(disconnect_ble_central_host)
          {
              if(disconnect_ble_central_host_counter == 10000) // 1sec = 100us x 10000
              {
                  HAL_setGpioHigh(halHandle,GPIO_Number_8);
              }
              else
              {
                  HAL_setGpioLow(halHandle,GPIO_Number_8);
                  disconnect_ble_central_host_counter++;
              }
          }
      }
      else
      {
          ms_since_last_ble_packet_from_App = 0;
          disconnect_ble_central_host = false;
          disconnect_ble_central_host_counter = 0;
          HAL_setGpioHigh(halHandle,GPIO_Number_8);
      }
  }

  state_gpio7 = HAL_readGpio(halHandle,GPIO_Number_7);
  if(!state_gpio7)
      disconnect_ble_central_host = true;

  state_gpio9 = HAL_readGpio(halHandle,GPIO_Number_9);
  if(!state_gpio9)
      disconnect_ble_after_60s = true;
  else
      disconnect_ble_after_60s = false;

  // computer dc bus current
  dc_bus_current_inV = (dc_bus_current_bits + 1.0) * 0.0008085; // 4068/3.289 = 0.0008085. adc to vcc bus => 4068, not 4095 (bad layout), but adc to gnd => 0 ( looks good)
  dc_bus_current_inA = dcbus_current_sensor_gain * (dc_bus_current_inV - dcbus_current_sensor_offset);
  // load cell readings before tared
  loadcell_front = HAL_readAnalogData(halHandle,ADC_ResultNumber_8); //   max value is 12-bit so varies from 0 to 4095
  loadcell_rear  = HAL_readAnalogData(halHandle,ADC_ResultNumber_9); // max value is 12-bit so varies from 0 to 4095
  loadcell_front_1  = HAL_readAnalogData(halHandle,ADC_ResultNumber_11); // max value is 12-bit so varies from 0 to 4095
  loadcell_rear_1  = HAL_readAnalogData(halHandle,ADC_ResultNumber_12); // max value is 12-bit so varies from 0 to 4095
  battery_thermistor  = HAL_readAnalogData(halHandle,ADC_ResultNumber_13); // max value is 12-bit so varies from 0 to 4095
  motor_thermistor  = HAL_readAnalogData(halHandle,ADC_ResultNumber_14); // max value is 12-bit so varies from 0 to 4095
  // compute electrical angle using encoder
  ENC_calcElecAngle(encHandle, gMotorVars.EncCount); // comment : optimize this to be written in enc.h and use iq math instead of float math
  // get Electrical Angle through encoder used for Commutation
  gMotorVars.EncAngle_iq =  ENC_getElecAngle(encHandle); //comment : optimize this to be taken care by ENC_calcElecAngle to make one function call
  // get Mechanical Angle through encoder
  // gMotorVars.MechAngle_iq =  ENC_getMechAngle(encHandle);
  // get Electrical Angle through bemf / FAST
//  gMotorVars.BEMFAngle_iq = EST_getAngle_pu(obj->estHandle);

  // if we are forcing alignment, using the Rs Recalculation, align the eQEP angle with the rotor angle
  if((EST_getState(obj->estHandle) == EST_State_Rs) && (USER_MOTOR_TYPE == MOTOR_Type_Pm))
  {
      HAL_setQepPosnCounts(halHandle,HAL_Qep_QEP1, USER_MOTOR_START_COUNT);
      HAL_setQepPosnCounts(halHandle,HAL_Qep_QEP2, USER_MOTOR_START_COUNT);
      Encoder_count_multiturn_offset = Encoder_count_multiturn;
  }

  Encoder_count_multiturn_corr = Encoder_count_multiturn - Encoder_count_multiturn_offset + USER_MOTOR_START_COUNT;
  // compute electrical angle using encoder_1
  //ENC_calcElecAngle(encHandle_1, EncCount_1); // comment : optimize this to be written in enc.h and use iq math instead of float math
  ENC_calcElecAngle(encHandle_1, Encoder_count_multiturn_corr);
  // get Electrical Angle through encoder_1 used for Commutation
  EncAngle_iq_1 =  ENC_getElecAngle(encHandle_1); //comment : optimize this to be taken care by ENC_calcElecAngle to make one function call

  // ball position before and after its tared
  if(tare_ball_position)
  {
      tare_ball_position = false;
      ball_position_tared = true;
      ball_position_offset = gMotorVars.EncCount - USER_MOTOR_START_COUNT;
  }

  if(ball_position_tared)
  {
      ball_position = gMotorVars.EncCount - ball_position_offset;
  }
  else
  {
      ball_position = gMotorVars.EncCount;
      ball_position_ma_sum_prev = ball_position_ma_sum;
      ball_velocityx10_ma_sum_prev = ball_velocityx10_ma_sum;
  }

  if(!ball_accelx200_circular_buffer_zeroing_done)
  {
      if(ball_accelx200_circular_buffer_location < ball_accelx200_circular_buffer_size)
      {
          ball_accelx200_circular_buffer[ball_accelx200_circular_buffer_location] = 0;
		  ball_accelx200_circular_buffer_location++;
      }
      else
      {
          ball_accelx200_circular_buffer_location = 0;
          ball_accelx200_circular_buffer_zeroing_done = true;
      }
  }
  if(!ball_velocityx10_circular_buffer_zeroing_done)
  {
      if(ball_velocityx10_circular_buffer_location < ball_velocityx10_circular_buffer_size)
      {
          ball_velocityx10_circular_buffer[ball_velocityx10_circular_buffer_location] = 0;
		  ball_velocityx10_circular_buffer_location++;
      }
      else
      {
          ball_velocityx10_circular_buffer_location = 0;
          ball_velocityx10_circular_buffer_zeroing_done = true;
      }
  }
  if(!ball_position_circular_buffer_zeroing_done)
  {
      if(ball_position_circular_buffer_location < ball_position_circular_buffer_size)
      {
          ball_position_circular_buffer[ball_position_circular_buffer_location] = 0;
		  ball_position_circular_buffer_location++;
      }
      else
      {
          ball_position_circular_buffer_location = 0;
          ball_position_circular_buffer_zeroing_done = true;
      }
  }

  if(!loadcell_circular_buffer_zeroing_done)
  {
      if(loadcell_circular_buffer_location < loadcell_circular_buffer_size)
      {
          loadcell_front_tared_circular_buffer[loadcell_circular_buffer_location] = 0;
          loadcell_front_1_tared_circular_buffer[loadcell_circular_buffer_location] = 0;
          loadcell_rear_tared_circular_buffer[loadcell_circular_buffer_location] = 0;
          loadcell_rear_1_tared_circular_buffer[loadcell_circular_buffer_location] = 0;
          loadcell_circular_buffer_location++;
      }
      else
      {
          loadcell_circular_buffer_location = 0;
          loadcell_circular_buffer_zeroing_done = true;
      }
  }

  if(ball_accelx200_circular_buffer_zeroing_done && ball_velocityx10_circular_buffer_zeroing_done && ball_position_circular_buffer_zeroing_done)
  {
      ball_position_ma_sum = ball_position_ma_sum - ball_position_circular_buffer[ball_position_circular_buffer_location] + ball_position;
      ball_position_circular_buffer[ball_position_circular_buffer_location] = ball_position;
      if(ball_position_circular_buffer_location == ball_position_circular_buffer_size_minus_1)
          ball_position_circular_buffer_location = 0 ;
      else
          ball_position_circular_buffer_location++;

      //ball_position_decimm = (uint16_t)(((ball_position - USER_MOTOR_START_COUNT) * ticks_to_decimm_conversion) + platform_to_roller_decimm);
      ball_position_decimm = (((ball_position_ma_sum - USER_MOTOR_START_COUNTx10) * ticks_to_decimm_conversion_by10) + platform_to_roller_decimm);
      ball_position_other_motor_decimm = ball_position_other_motor_recieved;

      range_of_motion_and_rep_counter();

      ball_velocityx10 = ball_position_ma_sum - ball_position_ma_sum_prev;
      ball_position_ma_sum_prev = ball_position_ma_sum;

      ball_velocityx10_ma_sum = ball_velocityx10_ma_sum - ball_velocityx10_circular_buffer[ball_velocityx10_circular_buffer_location] + ball_velocityx10;
      ball_velocityx10_circular_buffer[ball_velocityx10_circular_buffer_location] = ball_velocityx10;
      if(ball_velocityx10_circular_buffer_location == ball_velocityx10_circular_buffer_size_minus_1)
          ball_velocityx10_circular_buffer_location = 0 ;
      else
          ball_velocityx10_circular_buffer_location++;

      ball_accelx200 = ball_velocityx10_ma_sum - ball_velocityx10_ma_sum_prev;
      ball_velocityx10_ma_sum_prev = ball_velocityx10_ma_sum;

      ball_accelx200_ma_sum = ball_accelx200_ma_sum - ball_accelx200_circular_buffer[ball_accelx200_circular_buffer_location] + ball_accelx200;
      ball_accelx200_circular_buffer[ball_accelx200_circular_buffer_location] = ball_accelx200;
      if(ball_accelx200_circular_buffer_location == ball_accelx200_circular_buffer_size_minus_1)
          ball_accelx200_circular_buffer_location = 0 ;
      else
          ball_accelx200_circular_buffer_location++;
  }

  if(load_cells_tared)
  {
      loadcell_front_tared = loadcell_front - loadcell_front_offset ;
      loadcell_rear_tared = loadcell_rear - loadcell_rear_offset;
      loadcell_front_1_tared = loadcell_front_1 - loadcell_front_1_offset ;
      loadcell_rear_1_tared = loadcell_rear_1 - loadcell_rear_1_offset;
  }
  else
  {
      loadcell_front_tared = 0;
      loadcell_rear_tared = 0;
      loadcell_front_1_tared = 0;
      loadcell_rear_1_tared = 0;
  }

  if(tare_load_cells)
  {
      tare_load_cells = false;
      load_cells_tared = true;
      loadcell_front_offset =  loadcell_front - loadcell_diff_window;
      loadcell_rear_offset =  loadcell_rear - loadcell_diff_window;
      loadcell_front_1_offset =  loadcell_front_1 - loadcell_diff_window;
      loadcell_rear_1_offset =  loadcell_rear_1 - loadcell_diff_window;
   }

  if(loadcell_circular_buffer_zeroing_done)
  {
      loadcell_front_tared_ma_sum = loadcell_front_tared_ma_sum - loadcell_front_tared_circular_buffer[loadcell_circular_buffer_location] + loadcell_front_tared;
      loadcell_front_tared_circular_buffer[loadcell_circular_buffer_location] = loadcell_front_tared;
      loadcell_front_1_tared_ma_sum = loadcell_front_1_tared_ma_sum - loadcell_front_1_tared_circular_buffer[loadcell_circular_buffer_location] + loadcell_front_1_tared;
      loadcell_front_1_tared_circular_buffer[loadcell_circular_buffer_location] = loadcell_front_1_tared;
      loadcell_rear_tared_ma_sum = loadcell_rear_tared_ma_sum - loadcell_rear_tared_circular_buffer[loadcell_circular_buffer_location] + loadcell_rear_tared;
      loadcell_rear_tared_circular_buffer[loadcell_circular_buffer_location] = loadcell_rear_tared;
      loadcell_rear_1_tared_ma_sum = loadcell_rear_1_tared_ma_sum - loadcell_rear_1_tared_circular_buffer[loadcell_circular_buffer_location] + loadcell_rear_1_tared;
      loadcell_rear_1_tared_circular_buffer[loadcell_circular_buffer_location] = loadcell_rear_1_tared;

      if(loadcell_circular_buffer_location == loadcell_circular_buffer_size_minus_1)
          loadcell_circular_buffer_location = 0 ;
      else
          loadcell_circular_buffer_location++;
  }

  // enable run time functioning with ble, ball position tared
  if(setup_done && serial_exchange_working_in_both_directions && (!first_tare_ball_position_done))
  {
      if(tare_counter > 1000)
      {
          tare_ball_position = true;
          first_tare_ball_position_done = true;
          tare_load_cells = true;
          tare_counter = 0;
      }
      else
      {
          tare_counter++;
      }
  }

  if(first_tare_ball_position_done)
  {
      if(tare_counter == tare_counter_ball_position_reset) // 4 sec, made 40k for 10khz
      {
          tare_ball_position = true;
          tare_counter = 0;
      }
      else
      {
          if(ball_position_decimm > ball_position_decimm_reset) // need to think through, if this can be a problem??
              tare_counter = 0;
          else
              tare_counter++;
      }
  }

  // status flags
  Status_motor = (((uint16_t)solenoid_lock_flag_input) << 7) + (((uint16_t)bar_attachment_connected) << 6) + (((uint16_t)dynamic_iso_perturbation_flag) << 5) +
                  (((uint16_t)advanced_mode_flag) << 4) + (((uint16_t)smart_platform_enabled) << 3) + (((uint16_t)bar_stabilization_factor_enable) << 2) +
                  (((uint16_t)smart_barbell_safety_triggered) << 1) + ((uint16_t)smart_barbell_enabled);

  if(enable_start_set_using_lock_bit)
  {
      if(solenoid_lock_flag_input)
      {
          if(!set_started)
              set_started = true;
      }
      else
      {
          set_started = false;
      }
  }

  if(!set_started)
  {
      range_of_motion_states = ROM_Bottom_1;
  }

  if(set_started && bar_stabilization_factor_enable)
  {
      if((Bballs_other_motor > 0) && (Bballs > 0))
      {
          if(Rmax > Rmax_other_motor)
              Rmax = Rmax_other_motor;
          if(Rmin < Rmin_other_motor)
              Rmin = Rmin_other_motor;
      }
  }

  if(relay_switch_enabled)
  {
      {
          if(relay_switch_counter == 10000) //  1 sec delay
          {
              state_gpo_44_relay_switch = true;
              relay_switch_enabled = false;
              relay_switch_counter = 0;
          }
          else
          {
              relay_switch_counter++;
          }
      }
  }

  if(start_counter_enabled)
  {
      if(start_counter == 10000) // 1 sec delay
      {
          start_counter_enabled = false;
          user_switch_for_enable = true;
          start_counter = 0;
      }
      else
      {
          start_counter++;
      }
  }

  if(user_switch_for_enable)
  {
      if(charger_disconnected && serial_exchange_working_in_both_directions && (battery_voltage_centiV > Undervoltage_bus_centiV))
      {
          if(force_enable_delay == 20000) // 2 sec delay
          {
              if(!force_enabled)
              {
                  force_enabled = true;
                  force_enabled_other_motor = true;
              }
              user_switch_for_enable = false;
              undervoltage_shutdown_enable = true;
              force_enable_delay = 0;
          }
          else
          {
              force_enable_delay++;
          }
      }
  }

  if(undervoltage_shutdown_enable)
  {
      if(battery_voltage_centiV < Undervoltage_bus_centiV)
      {
          gMotorVars.Flag_enableSys = false;
          state_gpo_44_relay_switch = false;
      }
  }

  if(force_enabled && (!startup_process_done))
  {
      gMotorVars.Flag_Run_Identify = true;
      startup_process_done = true;
  }

  // enable force for various modes like 1) kill switch on/off 2) platform sensing on/off 2) foot location on platform
  if(force_enabled)
  {
      if(smart_platform_enabled)
      {
          if(platform_force_balanced_counter == 0)
          {
              platform_force_balanced_counter = 10000; // 1 sec
              if(platform_force_balanced)
                  wt_lb_set = wt_lb_desired; 
              else
                  wt_lb_set = wt_lb_default; 
          }
          else
          {
              platform_force_balanced_counter--;
          }
      }
      else
      {
          if(platform_force_balanced_counter == 0)
          {
              platform_force_balanced_counter = 3333; // was 5k for 15kz, made this 3.333k for 10kz
              if(!user_not_standing_on_platform)
              {
                  wt_lb_set = wt_lb_desired;
              }
              else
              {
                  wt_lb_set = wt_lb_default;
              }
          }
          else
          {
              platform_force_balanced_counter--;
          }
          wt_lb_set = wt_lb_desired; 
      }
  }
  else
  {
      wt_lb_set = wt_lb_default; 
  }

  if(first_tare_ball_position_done)
  {
      if (!( wt_lb_slewed_set == wt_lb_set))
      {
          diff_float = wt_lb_set - wt_lb_slewed_set;
          if( diff_float > slew_while_increasing_weight)
          {
              wt_lb_slewed_set = wt_lb_slewed_set + slew_while_increasing_weight;
          }
          else 
          {
              if(diff_float < -slew_while_decreasing_weight)
                  wt_lb_slewed_set = wt_lb_slewed_set - slew_while_decreasing_weight;
              else
                  wt_lb_slewed_set = wt_lb_set;
          }
      }
  }

    // code for force above start force position
    if(ball_position < start_force_position)
    {
        wt_lb_actually_set = wt_lb_default;
        enable_inertia_compensation = false;
        enable_friction_compensation = false;
    }
    else
    {
        if(ball_position < (start_force_position + ((uint16_t)start_force_position_ramp)))
        {
            enable_inertia_compensation = false;
            enable_friction_compensation = false;
            dX_float = (ball_position - start_force_position) * reciprocal_start_force_position_ramp;
            wt_lb_actually_set = wt_lb_default + ((wt_lb_slewed_set - wt_lb_default) * dX_float);
        }
        else
        {
            wt_lb_actually_set = wt_lb_slewed_set;
            enable_inertia_compensation = true;
            enable_friction_compensation = true;
        }

        if(bar_stabilization_factor_enable_manual) // active stabilization to keep bar horizontal
        {
            delta_ball_position_decimm = ball_position_decimm - ball_position_other_motor_decimm;
            bar_stabilization_factor = 1.0 +  (delta_ball_position_decimm * bar_stabilization_factor_rate);
            if(bar_stabilization_factor < 0.1)
              bar_stabilization_factor = 0.1;
            if(bar_stabilization_factor > 1.9)
              bar_stabilization_factor = 1.9;
            wt_lb_actually_set = wt_lb_actually_set * bar_stabilization_factor;
        }
    }

    if(bar_stabilization_factor_enable_manual)
    {
        enable_friction_compensation_force = false;
        enable_inertia_compensation_force = false;
    }
    else
    {
        enable_friction_compensation_force = true;
        enable_inertia_compensation_force = true;
    }

    if(enable_friction_compensation_force && enable_friction_compensation)
    {
        if(ball_velocityx10_ma_sum < 0) // outwards is +ve axis direction for position, velocity and acceleration
            wt_lb_actually_actually_set = 1.02 * wt_lb_actually_set + 1.365;  // eccentric phase, moving inwards
        else
            wt_lb_actually_actually_set = 0.835 * wt_lb_actually_set - 1.6; // concentric phase , moving outwards .made sure zero speed situation is counted as concentric

        if (!( wt_lb_actually_actually_set_slewed == wt_lb_actually_actually_set))
        {
            diff_float_1 = wt_lb_actually_actually_set - wt_lb_actually_actually_set_slewed;
            if( diff_float_1 > slew_while_increasing_weight_friction)
            {
                wt_lb_actually_actually_set_slewed = wt_lb_actually_actually_set_slewed + slew_while_increasing_weight_friction;
            }
            else
            {
                if(diff_float_1 < -slew_while_decreasing_weight_friction)
                    wt_lb_actually_actually_set_slewed = wt_lb_actually_actually_set_slewed - slew_while_decreasing_weight_friction;
                else
                    wt_lb_actually_actually_set_slewed = wt_lb_actually_actually_set;
            }
        }
    }
    else
    {
        wt_lb_actually_actually_set = wt_lb_actually_set;
        wt_lb_actually_actually_set_slewed = wt_lb_actually_actually_set;
    }

    gMotorVars.IqRef_A = _IQ(-wt_lb_actually_actually_set_slewed * 0.5);

    // makes sure the current requested is never above the max current that saturates the motor
    if(gMotorVars.IqRef_A < _IQ(IqRef_A_max_limit))
        gMotorVars.IqRef_A = _IQ(IqRef_A_max_limit);
    // makes sure the current requested is never too low or causes the spool to throw out rope
    if(gMotorVars.IqRef_A > _IQ(IqRef_A_min_limit))
        gMotorVars.IqRef_A = _IQ(IqRef_A_min_limit);

    IqRef_pu = _IQmpy(gMotorVars.IqRef_A,_IQ(RECIPROCAL_USER_IQ_FULL_SCALE_CURRENT_A));

    if(enable_inertia_compensation_force && enable_inertia_compensation_log && enable_inertia_compensation && enable_friction_compensation)
    {
        //rotor_inertia_factor_concentric_accel_iq = _IQ(0.0);
        rotor_inertia_factor_concentric_decel_iq = _IQmpy (_IQ(-0.0001),_IQ(wt_lb_actually_set)) + _IQ(0.003);
        if(_IQtoF(rotor_inertia_factor_concentric_decel_iq) < 0.0)
            rotor_inertia_factor_concentric_decel_iq = _IQ(0.0);
        //rotor_inertia_factor_eccentric_accel_iq = _IQ(0.0);
        rotor_inertia_factor_eccentric_decel_iq = rotor_inertia_factor_concentric_decel_iq;

        if(ball_velocityx10_ma_sum < 0)  //outwards is +ve axis direction for position, velocity and acceleration
        {   // eccentric phase , moving inwards
            if(ball_accelx200_ma_sum < 0 )
                IqRef_pu_corr_inertia_accel = _IQmpy(rotor_inertia_factor_eccentric_decel_iq, _IQ22(ball_accelx200_ma_sum));
            // deceleration, outwards is +ve axis direction for position, velocity and acceleration
           else
               IqRef_pu_corr_inertia_accel = _IQmpy(rotor_inertia_factor_eccentric_accel_iq, _IQ22(ball_accelx200_ma_sum));
            // acceleration , outwards is +ve axis direction for position, velocity and acceleration
        }
        else
        {   // concentric phase , moving outwards
            if(ball_accelx200_ma_sum < 0 )
                IqRef_pu_corr_inertia_accel = _IQmpy(rotor_inertia_factor_concentric_decel_iq, _IQ22(ball_accelx200_ma_sum));
            // deceleration, outwards is +ve axis direction for position, velocity and acceleration
            else
                IqRef_pu_corr_inertia_accel = _IQmpy(rotor_inertia_factor_concentric_accel_iq, _IQ22(ball_accelx200_ma_sum));
            // acceleration, outwards is +ve axis direction for position, velocity and acceleration
        }
        IqRef_pu = IqRef_pu + IqRef_pu_corr_inertia_accel;
    }
    else
    {
        IqRef_pu_corr_inertia_accel = _IQ(0.0); //wt_lb_correction_inertia_accel = 0.0;
    }

    if(IqRef_pu < iq_var_max_limit)
        IqRef_pu = iq_var_max_limit;
    if(IqRef_pu > iq_var_min_limit)
        IqRef_pu = iq_var_min_limit;

    // Set the Iq reference in per unit
    CTRL_setIq_ref_pu(ctrlHandle, IqRef_pu);

    if(enable_friction_compensation_force && enable_friction_compensation)
    {
        if(ball_velocityx10_ma_sum < 0) // outwards is +ve axis direction for position, velocity and acceleration
            wt_lb_actually_set_measured = 0.98 * wt_lb_actually_actually_set_slewed - 1.338 ; //wt_lb_actually_actually_set = 1.02 * wt_lb_actually_set + 1.365;  // eccentric phase, moving inwards
        else
            wt_lb_actually_set_measured = 1.1976 * wt_lb_actually_actually_set_slewed + 1.916  ; //wt_lb_actually_actually_set = 0.835 * wt_lb_actually_set - 1.6; // concentric phase , moving outwards .made sure zero speed situation is counted as concentric
    }
    else
    {
        wt_lb_actually_set_measured = wt_lb_actually_actually_set_slewed;
    }

  // run the controller // comment CTRL_run should be in ctrl.h file to be faster?
  CTRL_run(ctrlHandle,halHandle,&gAdcData,&gPwmData,gMotorVars.EncAngle_iq, IqRef_pu_pos_max, IqRef_pu_neg_max);
  // write the PWM compare values
  HAL_writePwmData(halHandle,&gPwmData);
  // setup the controller
  CTRL_setup(ctrlHandle); // comment : whats going on here, is this needed?

  if(log_init)
  {
      if(log_array_pos < LOG_ARRAY_SIZE)
      {
          log_EncCount_diff[log_array_pos] = 0;
          log_EncAngle_diff[log_array_pos] = 0.0;
//          log_EncCount[log_array_pos]= 0;
//          log_EncCount_1[log_array_pos] = 0;
//          log_EncCount_SPI[log_array_pos] = 0;
          log_array_pos++;
      }
      else
      {
          log_init = false;
          log_array_pos = 0;
      }
  }
//
//  if(ball_position_decimm > start_logging_decimm)
//  {
//      if(log_array_start && (!log_array))
//      {
//          log_array = true;
//          log_array_start = false;
//      }
//  }

//  if(log_array)
//  {
//      if(log_array_pos < LOG_ARRAY_SIZE)
//      {
//            if(log_counter == log_counter_max) // logging a sample at every (log_counter_max * 100us)
//            {
////                log_ball_position_ma_sum[log_array_pos]= ball_position_ma_sum;
////                log_ball_velocityx10_ma_sum[log_array_pos] = ball_velocityx10_ma_sum;
////                log_ball_accelx200_ma_sum[log_array_pos] = ball_accelx200_ma_sum;
////                log_wt_lb[log_array_pos] = wt_lb_actually_actually_set_slewed;
////                log_wt_lb_correction_inertia_accel[log_array_pos] =  wt_lb_correction_inertia_accel;
//                log_array_pos++;
//                log_counter = 1;
//            }
//            else
//            {
//                log_counter++;
//            }
//      }
//      else
//      {
//          log_array = false;
//          log_array_pos = 0;
//      }
//  }


  if(log_array)
  {
      if(gMotorVars.EncCount < (LOG_ARRAY_SIZE + 20480))
      {
          log_EncCount_diff[gMotorVars.EncCount - 20480] = gMotorVars.EncCount - Encoder_count_multiturn_corr;
          log_EncAngle_diff[gMotorVars.EncCount - 20480] = _IQtoF(gMotorVars.EncAngle_iq) - _IQtoF(EncAngle_iq_1);
//          log_EncCount[gMotorVars.EncCount - 20480] = gMotorVars.EncCount;
//          log_EncCount_1[gMotorVars.EncCount - 20480] = EncCount_1;
//          log_EncCount_SPI[gMotorVars.EncCount - 20480] = Encoder_count_multiturn_corr;
      }
  }

  // toggle status LED
  if(startup_process_done)
  {
      if(!ble_central_host_connected)
      {
          // toggle status LED
          if(gLEDcnt >= (uint32_t)(USER_ISR_FREQ_Hz / LED_BLINK_FREQ_Hz))
          {
              HAL_toggleLed(halHandle,GPIO_Number_34);
              gLEDcnt = 0;
          }
          else
          {
              gLEDcnt++;
          }
      }
      else
      {
          HAL_turnActiveHighLedOff(halHandle,GPIO_Number_34);
      }
  }

  // millisecond counter for timestamp
    if(ms_counter == 10) // made 10 for 10khz
    {
        ms_counter = 1;
        timestamp++;
        if(ms_since_last_ble_packet_from_App == 60000) // 60 sec
        {
            ms_since_last_ble_packet_from_App = 0;
            if(disconnect_ble_after_60s)
                disconnect_ble_central_host = true;
        }
        else
        {
            ms_since_last_ble_packet_from_App++;
        }
    }
    else
    {
        ms_counter++;
    }

    state_gpio40 = HAL_readGpio(halHandle,GPIO_Number_40);
    ball_stop_down = state_gpio40;
    state_gpio11 = HAL_readGpio(halHandle,GPIO_Number_11);
    ble_central_host_connected = state_gpio11;

    if(enable_solenoid_brake)
    {
        if(solenoid_brake_released)
        {
            if(enable_solenoid_brake_counter == enable_solenoid_brake_counter_max)
            {
                duty_cycle = duty_cycle_5v;
                //duty_cycle = 0.5;
            }
            else
            {
                duty_cycle = duty_cycle_10v;
                //duty_cycle = 1.0;
                enable_solenoid_brake_counter++;
            }
        }
        else
        {
            duty_cycle = 0.0;
            enable_solenoid_brake_counter = 0;
        }
    }
    else
    {
        enable_solenoid_brake_counter = 0;
    }

    HAL_setDacParameters(&gDacData,duty_cycle);
    HAL_writeDacData(halHandle,&gDacData);

    // read the timer 2 value and update the CPU usage module
    timer2Cnt = HAL_readTimerCnt(halHandle,2);
    CPU_TIME_run(cpu_timeHandle,timer2Cnt);

    //HAL_setGpioLow(halHandle,GPIO_Number_6);
  return;
} // end of mainISR() function

//@} //defgroup
// end of file
// not done - battery current send from right side to left side, add them together and send out on ble as total battery current
// not done - motor thermistor and battery thermistor
// not done - when smart platform is enabled, rep counter and rom estimator should not start until force is turned on by stepping to mid band
